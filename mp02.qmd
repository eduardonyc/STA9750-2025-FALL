---
title: "STA 9750 Mini-Project #02: Making Backyards Affordable for All"
author: "Eduardo Alarcon"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
execute:
  message: false
  warning: false
---

<style>
strong, b {
  font-weight: bold !important;
}
</style>


```{r}
#| label: setup
#| message: false
#| warning: false

# Load all required packages
library(tidyverse)    
library(glue)
library(readxl)
library(tidycensus)
library(httr2)
library(rvest)
library(DiagrammeR)
library(stringr)
library(gt)
library(ggplot2)
library(scales)
library(dplyr)
library(tidyverse)
library(knitr)
library(gganimate)
library(gifski)
library(DT)
library(readr)
library(htmltools)
library(ggrepel)
library(plotly)
library(kableExtra)
library(tidyr)
library(purrr)
library(rlang)

```

## Task 1: Data Import

### Data Acquistion

Following the guidelines for Mini Project #02, this section executes the instructor-provided data acquisition code. The code downloads and prepares five critical datasets:

1. **ACS Data** (2009-2023): Household income, rent, population, and households by CBSA
2. **Building Permits** (2009-2023): New housing units permitted by CBSA
3. **BLS Industry Codes**: NAICS classification system for occupation analysis
4. **BLS QCEW Data** (2009-2023): Employment and wages by industry and CBSA

These datasets are part of all subsequent tasks to analyze housing affordability across metropolitan areas in the United States.

```{r}

if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

library <- function(pkg){
    ## Mask base::library() to automatically install packages if needed
    ## Masking is important here so downlit picks up packages and links
    ## to documentation
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

library(tidyverse)
library(glue)
library(readxl)
library(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") %>%
                mutate(year=yy) %>%
                select(-moe, -variable) %>%
                rename(!!variable := estimate)
        }) %>% bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") %>%
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") %>%
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") %>%
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") %>%
    rename(households = B11001_001)
```


```{r}

get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) %>% bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) %>%
                na.omit() %>%
                select(CBSA, Total) %>%
                mutate(year = yy) %>%
                rename(new_housing_units_permitted = Total)
        }) %>% bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()
```


```{r}

library(httr2)
library(rvest)
get_bls_industry_codes <- function(){
    fname <- fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    
    if(!file.exists(fname)){
    
        resp <- request("https://www.bls.gov") %>% 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") %>%
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") %>% 
            req_error(is_error = \(resp) FALSE) %>%
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) %>%
            html_element("#naics_titles") %>% 
            html_table() %>%
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) %>%
            select(-`Industry Title`) %>%
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) %>%
            filter(!is.na(depth))
        
        naics_table <- naics_table %>% 
            filter(depth == 4) %>% 
            rename(level4_title=title) %>% 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) %>%
            left_join(naics_table, join_by(level1_code == Code)) %>%
            rename(level1_title=title) %>%
            left_join(naics_table, join_by(level2_code == Code)) %>%
            rename(level2_title=title) %>%
            left_join(naics_table, join_by(level3_code == Code)) %>%
            rename(level3_title=title) %>%
            select(-starts_with("depth")) %>%
            rename(level4_code = Code) %>%
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code)
    
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
    
}

INDUSTRY_CODES <- get_bls_industry_codes()
```


```{r}

library(httr2)
library(rvest)
library(glue)

get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") %>% 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) %>%
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") %>% 
                    req_retry(max_tries=5) %>%
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) %>% 
                mutate(YEAR = yy) %>%
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) %>%
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) %>%
                filter(str_detect(industry_code, "-", negate=TRUE)) %>%
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) %>%
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) %>%
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) %>% 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) %>% bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()

```

```{r}



```

## Extra Credit # 1

### Data Integration Structure 

This analysis integrates data from three federal agencies. The Census Bureau's American Community Survey (ACS), the Census Building Permits database, and the Bureau of Labor Statistics (BLS) each use distinct identification systems for Core-Based Statistical Areas (CBSAs). 

### Integration Strategy

The four main ACS data tables (INCOME, RENT, POPULATION, and HOUSEHOLDS) are all organized by location (GEOID) and year. Because they share this identical structure, they are easy to combine using standard `left_join()` operations. These tables provide the core economic and demographic data for the analysis.

To connect ACS to the Building Permits database, we standardize both to a common 5-character CBSA key by copying ACS GEOID as a string key, and zero-padding the Permits integer CBSA to 5 characters.

```r
acs <- acs %>%
  mutate(
    cbsa_str = GEOID, 
    CBSA = as.integer(str_extract(GEOID, "[0-9]+"))
  )
permits <- permits %>%
  mutate(cbsa_str = sprintf("%05d", CBSA))
```

The second transformation links BLS wage data to Census tables by converting BLS FIPS format back to standard 5-digit CBSA codes. BLS codes like "C1018" need to be padded to match Census format "10180":

```r
mutate(.digits  = sub("^C", "", FIPS), 
cbsa_str = ifelse(nchar(.digits) == 4, paste0(.digits, "0"), .digits)) %>%
select(-.digits)
```

Additionally, there is a different naming convention for "year." Specifically, ACS and Census tables use lowercase `year`, while BLS tables use uppercase `YEAR`. Join operations must explicitly map these columns:

```r
left_join(WAGES, by = c("FIPS", "year" = "YEAR"))
```

Lastly, the INDUSTRY_CODES table lists industry categories (NAICS) to facilitate job analysis. To use it, we must change the INDUSTRY column from an integer to a character type, so it can match the level4_code column.

```r
WAGES %>%
  mutate(INDUSTRY = as.character(INDUSTRY)) %>%
  left_join(INDUSTRY_CODES, by = c("INDUSTRY" = "level4_code"))
```

The Relationship Diagram below highlights these naming conventions, showing the connections between these data sources.

```{r}

#| label: fig-relationship-diagram
#| fig-cap: "Data Integration Architecture: Entity Relationships & Transformation Logic Across Federal Data Sources"
#| out-width: "100%"

grViz("
digraph MP02_ERD {
  
  graph [rankdir=TB, fontname=Arial, bgcolor=white, splines=polyline, nodesep=2, ranksep=3.5, margin='1.5,0.5',
         label='Data Integration Architecture:\\nEntity Relationships & Transformation Logic Across Federal Data Sources', 
         labelloc='t', 
         fontsize=50]
  node [shape=box, style='rounded,filled', fontname=Arial, fontsize=28, margin=0.7, width=7, height=2.5]
  edge [fontname=Arial, fontsize=22, labelfloat=true, labeldistance=4]
  
  INCOME [label='INCOME\\n\\nGEOID (PK)\\nNAME\\nyear (PK)\\n\\nhousehold_income', fillcolor='lightblue']
  RENT [label='RENT\\n\\nGEOID (PK)\\nNAME\\nyear (PK)\\n\\nmonthly_rent', fillcolor='lightblue']
  POPULATION [label='POPULATION\\n\\nGEOID (PK)\\nNAME\\nyear (PK)\\n\\npopulation', fillcolor='lightblue']
  HOUSEHOLDS [label='HOUSEHOLDS\\n\\nGEOID (PK)\\nNAME\\nyear (PK)\\n\\nhouseholds', fillcolor='lightblue']
  PERMITS [label='PERMITS\\n\\nCBSA (PK)\\nyear (PK)\\n\\nnew_housing_units_permitted', fillcolor='#90EE90', width=8]
  WAGES [label='WAGES\\n\\nFIPS (PK)\\nINDUSTRY (PK, FK)\\nYEAR (PK)\\n\\nEMPLOYMENT\\nTOTAL_WAGES\\nAVG_WAGE', fillcolor='lightcoral', width=8, height=3]
  INDUSTRY [label='INDUSTRY_CODES\\n\\nlevel4_code (PK)\\n\\nlevel4_title\\nlevel3_code/title\\nlevel2_code/title\\nlevel1_code/title', fillcolor='lightcoral', width=8, height=3]
  
  INCOME -> RENT [label='      GEOID + year      ', color=blue, penwidth=5, fontcolor=blue, fontsize=22]
  RENT -> POPULATION [label='      GEOID + year      ', color=blue, penwidth=5, fontcolor=blue, fontsize=22]
  POPULATION -> HOUSEHOLDS [label='      GEOID + year      ', color=blue, penwidth=5, fontcolor=blue, fontsize=22]
  POPULATION -> PERMITS [label='      Extract CBSA      \\n      from GEOID      ', color=orange, penwidth=5, style=dashed, fontcolor='#CC5500', fontsize=22]
  PERMITS -> WAGES [label='      Format CBSA      \\n      to FIPS      ', color=orange, penwidth=5, style=dashed, fontcolor='#CC5500', fontsize=22]
  WAGES -> INDUSTRY [label='      INDUSTRY to      \\n      level4_code      ', color=red, penwidth=5, fontcolor=red, fontsize=22]
  
  {rank=same; HOUSEHOLDS; PERMITS}
}
", height = "1200px", width = "100%")

```

### Geographic Identification Challenges

As illustrated in the diagram above, each data source uses a different convention for identifying the same geographic units:

- **Census ACS Tables** use alphanumeric `GEOID` strings (e.g., "CBSA10180" for Abilene, TX Metro Area)
- **Census Building Permits** use integer `CBSA` codes (e.g., 10180)
- **BLS Wage Data** use formatted `FIPS` strings with "C" prefix (e.g., "C1018" for what Census calls CBSA 10180 - note BLS drops the trailing zero)

These differences represent significant data engineering challenges. A naive, or direct join would fail to match any records across these sources, despite all three referring to identical geographic areas.

### Implications for Reproducibility

This transformation process is essential for the analysis. It supports accurate location matching and makes our work reliable. The accompanying relationship diagram visually confirms that this complex integration is managed appropriately.

### Analytical Limitations

This analysis has three main limitations:

- **Metro-Only Focus**: The data covers 380+ metropolitan areas (86% of the U.S. population) but excludes rural regions; thus, all findings apply to urban housing markets, not the entire country
- **Population Growth Data**: The data combines new migrants (who need housing now) with natural increase or births (who will not), leading to likely understated housing demand.  
- **Multi-State Metros**: Data for metros that cross state lines (like NYC-NJ-PA or DC-VA-MD) link to an individual primary state, which can skew state-level rankings.

**Impact on Mini Project 2 Findings**: Because these metrics do not fully capture the entirety of the country, these findings, including YIMBY and NIMBY candidates, should be considered conservative.

## Task 2: Multi-Table Questions

### Question 1: Largest Housing Permits (2010-2019)

Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?

```{r}

# Step 1: Filter PERMITS for 2010-2019 and sum by CBSA
permits_2010_2019 <- PERMITS %>%
  filter(year >= 2010 & year <= 2019) %>%
  group_by(CBSA) %>%
  summarize(total_new_units = sum(new_housing_units_permitted, na.rm = TRUE)) %>%
  arrange(desc(total_new_units))

# Step 2: Get CBSA names
cbsa_names <- POPULATION %>%
  filter(year == 2019) %>%
  mutate(CBSA = as.integer(str_extract(GEOID, "[0-9]+"))) %>%
  select(CBSA, NAME)

# Step 3: Join and get top 5
top_5_permits <- permits_2010_2019 %>%
  left_join(cbsa_names, by = "CBSA") %>%
  head(5) %>%
  mutate(rank = row_number()) %>%
  select(rank, NAME, total_new_units)

# Get the winner
winner_name <- top_5_permits %>% slice(1) %>% pull(NAME)
winner_units <- top_5_permits %>% slice(1) %>% pull(total_new_units)

# Create styled gt table
top_5_permits %>%
  gt() %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(16)
  ) %>%
  tab_header(
    title = md("**Table 1: Top 5 CBSAs for New Housing Units Permitted**"),
    subtitle = "2010–2019 (inclusive)"
  ) %>%
  cols_align(
    align = "left",
    columns = everything()
  ) %>%
  cols_label(
    rank = "Rank",
    NAME = "CBSA",
    total_new_units = "Total New Units"
  ) %>%
  fmt_number(
    columns = total_new_units,
    decimals = 0
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#d4edda"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(rows = rank == 1)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(md("Source: **U.S. Census Bureau Building Permits Survey**"))

```

**Answer:** The **`r winner_name`** permitted the largest number of new housing units from 2010 to 2019, with **`r format(winner_units, big.mark = ",")`** total new units permitted during the decade.

### Question 2: Albuquerque Peak Year

In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?

```{r}

# Filter for Albuquerque and get all years
albuquerque_permits <- PERMITS %>%
  filter(CBSA == 10740) %>%
  arrange(year) %>%
  select(year, new_housing_units_permitted)

# Get peak year
peak_year <- albuquerque_permits %>%
  slice_max(new_housing_units_permitted, n = 1) %>%
  pull(year)

peak_units <- albuquerque_permits %>%
  slice_max(new_housing_units_permitted, n = 1) %>%
  pull(new_housing_units_permitted)

# Create visualization
ggplot(albuquerque_permits, aes(x = year, y = new_housing_units_permitted)) +
  geom_line(color = "steelblue", linewidth = 1.5) +
  geom_point(size = 3, color = "steelblue") +
  geom_point(
    data = albuquerque_permits %>% filter(year == 2020),
    aes(x = year, y = new_housing_units_permitted),
    color = "red", size = 4
  ) +
  geom_point(
    data = albuquerque_permits %>% filter(year == 2021),
    aes(x = year, y = new_housing_units_permitted),
    color = "darkgreen", size = 4
  ) +
  annotate("text", x = 2020,
           y = albuquerque_permits$new_housing_units_permitted[albuquerque_permits$year == 2020],
           label = "COVID Dip", color = "red", hjust = 1.2, vjust = 1.5) +
  annotate("text", x = 2021,
           y = albuquerque_permits$new_housing_units_permitted[albuquerque_permits$year == 2021],
           label = "Peak", color = "darkgreen", hjust = 0.5, vjust = -1.5) +
  labs(
    title = "Housing Permits in Albuquerque, NM (CBSA 10740)",
    subtitle = "Note the 2020 COVID dip and 2021 rebound",
    x = "Year",
    y = "New Housing Units Permitted"
  ) +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0.05, 0.15))) +
  coord_cartesian(clip = "off")

# Create styled table showing all years
albuquerque_permits %>%
  mutate(year = as.character(year)) %>%
  gt() %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(16)
  ) %>%
  tab_header(
    title = md("**Table 2: Albuquerque Housing Permits by Year**"),
    subtitle = "CBSA 10740 (2009–2023)"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  cols_label(
    year = "Year",
    new_housing_units_permitted = "New Housing Units Permitted"
  ) %>%
  fmt_number(
    columns = new_housing_units_permitted,
    decimals = 0
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#d1ecf1"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(rows = year == as.character(peak_year))
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#f8d7da"),
      cell_text(style = "italic")
    ),
    locations = cells_body(rows = year == "2020")
  ) %>%
  tab_style(
    style = 
      cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(md("Source: **U.S. Census Bureau Building Permits Survey**"))

```

**Answer:** Albuquerque, NM (CBSA 10740) permitted the most new housing units in **`r peak_year`** with **`r format(peak_units, big.mark = ",")`** units.

**COVID-19 Artifact Note:** The 2021 spike in construction permits is misleading. It represents a backlog of delayed 2020 permits receiving approval after pandemic shutdowns ended. Many metros show this same "2020 dip, 2021 rebound" trend. As a result, it is not indicative of real change in demand for housing.

### Question 3: Highest Average Individual Income by State (2015)

Which state (not CBSA) had the highest average individual income in 2015?

```{r}

# Step 1: Join the three tables for 2015
income_2015 <- INCOME %>%
  filter(year == 2015) %>%
  left_join(HOUSEHOLDS %>% filter(year == 2015), by = c("GEOID", "NAME", "year")) %>%
  left_join(POPULATION %>% filter(year == 2015), by = c("GEOID", "NAME", "year"))

# Step 2: Calculate total income per CBSA and extract state
cbsa_income <- income_2015 %>%
  mutate(
    total_income = household_income * households,
    state = str_extract(NAME, ", (.{2})", group = 1)
  ) %>%
  select(GEOID, NAME, state, total_income, population)

# Step 3: Sum by state
state_income <- cbsa_income %>%
  group_by(state) %>%
  summarize(
    total_state_income = sum(total_income, na.rm = TRUE),
    total_state_population = sum(population, na.rm = TRUE)
  ) %>%
  mutate(avg_individual_income = total_state_income / total_state_population) %>%
  arrange(desc(avg_individual_income))

# Step 4: Get the top state
top_state_abb <- state_income %>%
  slice(1) %>%
  pull(state)

top_state_income <- state_income %>%
  slice(1) %>%
  pull(avg_individual_income)

# Step 5: Convert abbreviation to full state name
state_df <- data.frame(
  abb  = c(state.abb, "DC", "PR"),
  name = c(state.name, "District of Columbia", "Puerto Rico")
)

top_state_name <- state_df %>%
  filter(abb == top_state_abb) %>%
  pull(name)

# Show top 10 states with formatted income
top_10_states <- state_income %>%
  head(10) %>%
  left_join(state_df, by = c("state" = "abb")) %>%
  mutate(
    # Format income with dollar sign and commas
    income_formatted = paste0("$", format(round(avg_individual_income, 2), 
                                         big.mark = ",", 
                                         nsmall = 2)),
    note = case_when(
      state == "DC" ~ "⚠️ 100% Multi-State ⚠️",
      state %in% c("NY", "MD", "VA", "PA", "NJ") ~ "Contains Multi-State CBSAs",
      TRUE ~ ""
    )
  ) %>%
  select(name, state, income_formatted, total_state_population, note)

top_10_states %>%
  gt() %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(16)
  ) %>%
  tab_header(
    title = md("**Table 3: Top 10 States by Average Individual Income (2015)**"),
    subtitle = "Ranked by average individual income across metropolitan areas"
  ) %>%
  fmt_number(columns = total_state_population, decimals = 0, sep_mark = ",") %>%
  cols_align(
    align = "left",
    columns = everything()
  ) %>%
  cols_label(
    name = "State",
    state = "Abbr",
    income_formatted = "Avg Individual Income",
    total_state_population = "Total Population",
    note = "Note"
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(
    md("Source: **U.S. Census Bureau, American Community Survey (ACS), 2015**")
    )


```

**Answer:** **`r top_state_name`** appears highest in 2015 at $`r format(round(top_state_income, 2), big.mark = ",")`, **but** that result is inflated by:

- **Multi-state Washington CBSA** attribution
- **CBSA-only coverage**excludes rural areas

**Most comparable state-to-state finding:** Excluding the mentioned artifacts and using states with strong single-state CBSA coverage, **Massachusetts** ranks highest, followed by **Connecticut**.

*Note:* Multi-state CBSAs account for ~27% of the population in this dataset, or ~10% of CBSAs by count.

```{r}

#| label: multi_state_cbsa_prevalence
#| code-fold: true
#| code-summary: "Show code for multi-state CBSA shares"

# ---- require a CBSA-level ACS table named POPULATION ----
if (!exists("POPULATION")) {
  stop("Please load your ACS CBSA table as POPULATION (with columns NAME, GEOID, year, population).")
}

# Helper: pick the first matching column name
pick_col <- function(df, candidates){
  hit <- intersect(candidates, names(df))
  if (!length(hit)) stop("Missing columns: ", paste(candidates, collapse=", "))
  hit[1]
}

# Flexible column detection
name_col <- pick_col(POPULATION, c("NAME","name"))
geoid_col <- pick_col(POPULATION, c("GEOID","CBSA","cbsa"))
year_col  <- pick_col(POPULATION, c("year","YEAR"))
pop_col   <- pick_col(POPULATION, c("population","B01003_001"))

# ---- filtering to target year (2015) ----
pop15 <- POPULATION %>%
  filter(.data[[year_col]] == 2015) %>%
  transmute(
    cbsa = if (geoid_col == "GEOID")
              as.integer(str_extract(.data[[geoid_col]], "\\d+"))
           else as.integer(.data[[geoid_col]]),
    name = .data[[name_col]],
    population = as.numeric(.data[[pop_col]])
  ) %>%
  distinct(cbsa, .keep_all = TRUE)

# Extract the "state block" after the comma: e.g., "GA" or "DC-VA-MD-WV"
pop15 <- pop15 %>%
  mutate(
    state_block = str_extract(name, "(?<=,\\s)[A-Z]{2}(?:-[A-Z]{2})*"),
    n_states    = if_else(is.na(state_block), 1L, str_count(state_block, "-") + 1L),
    is_multi    = n_states > 1
  )

# ---- metrics ----
metrics <- summarise(pop15,
  `Population share (%)` = 100 * sum(population[is_multi], na.rm = TRUE) / sum(population, na.rm = TRUE),
  `CBSA share (%)`       = 100 * mean(is_multi),
  `Total CBSAs`          = n(),
  `Multi-state CBSAs`    = sum(is_multi)
)

# ---- display as a neat table ----
gt(metrics) %>%
    tab_options(
    table.width  = gt::pct(100),
    table.align  = "left",  
    heading.align = "left"  
  ) %>%
  cols_align(
    align = "left",
    columns = everything()
  ) %>%
  tab_header(title = md("**Table 4: Multi-state CBSA Prevalence (2015)**")) %>%
  tab_source_note(md("Population share = share of **people** living in multi-state CBSAs (headline). CBSA share = share of CBSAs that are multi-state (by count).")) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  fmt_number(columns = c(`Population share (%)`, `CBSA share (%)`), decimals = 1) %>%
  fmt_number(columns = c(`Total CBSAs`, `Multi-state CBSAs`), decimals = 0) 

```

### Question 4: Data Scientists by CBSA Over Time

What is the last year in which the NYC CBSA had the most data scientists in the country? In recent years, the San Francisco CBSA has had the most data scientists.

```{r}

# Prepare data
data_scientists <- WAGES %>%
  filter(INDUSTRY == 51821) %>%
  rename(std_cbsa = FIPS, year = YEAR)

cbsa_names <- POPULATION %>%
  filter(year == 2019) %>%
  mutate(
    CBSA = as.integer(str_extract(GEOID, "[0-9]+")),
    std_cbsa = paste0("C", str_sub(as.character(CBSA), 1, 4))
  ) %>%
  select(std_cbsa, NAME)

# Calculate last NYC year 
last_nyc_year <- data_scientists %>%
  group_by(std_cbsa, year) %>%
  summarize(total_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") %>%
  left_join(cbsa_names, by = "std_cbsa") %>%
  group_by(year) %>%
  slice_max(total_employment, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  filter(str_detect(NAME, "New York")) %>%
  pull(year) %>%
  max()

# Focus on the transition period: 2014–2017
transition_years <- data_scientists %>%
  filter(year %in% c(2014, 2015, 2016, 2017)) %>%
  group_by(std_cbsa, year) %>%
  summarize(total_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") %>%
  left_join(cbsa_names, by = "std_cbsa") %>%
  group_by(year) %>%
  slice_max(total_employment, n = 3, with_ties = FALSE) %>%
  ungroup() %>%
  arrange(year, desc(total_employment)) %>%
  group_by(year) %>%
  mutate(rank = row_number()) %>%
  ungroup() %>%
  mutate(year = as.character(year)) %>%
  select(year, rank, NAME, total_employment) %>%
  arrange(year, rank)

# ---- gt table (with header, options, and source) ----
transition_years %>%
  gt() %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(16)
  ) %>%
  tab_header(
    title = md("**Table 5: The NYC-to-San Francisco Transition (2014–2017)**"),
    subtitle = "Top 3 CBSAs by total employment in NAICS 51821 for each year"
  ) %>%
  cols_label(
    year = "Year",
    rank = "Rank",
    NAME = "CBSA",
    total_employment = "Employment"
  ) %>%
  fmt_number(
    columns = total_employment,
    decimals = 0,
    use_seps = TRUE
  ) %>%
  cols_align(
    align = "left",
    columns = c(year, rank, NAME, total_employment)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(
    md(paste0(
      "**Source.** BLS QCEW (NAICS 51821), 2014–2017; U.S. Census Bureau (2019) for CBSA names. "))
  )

```

**Answer:** The last year in which the New York City CBSA had the most data scientists and business analysts (NAICS 51821) in the country was **`r last_nyc_year`**. As shown in the table above, San Francisco has led the nation since then, reflecting the tech industry's concentration in Silicon Valley.

### Question 5: Finance & Insurance Wages in NYC

What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?

```{r}

# Identify NYC CBSA code
nyc_cbsa_code <- "C3562"

# Calculate finance wages as fraction of total wages by year
nyc_wage_share <- WAGES %>%
  filter(FIPS == nyc_cbsa_code, YEAR != 2020) %>%  # Omitting 2020 per data issues
  mutate(
    is_finance = str_starts(as.character(INDUSTRY), "52")
  ) %>%
  group_by(year = YEAR) %>%
  summarize(
    wages_total = sum(TOTAL_WAGES, na.rm = TRUE),
    wages_fin = sum(if_else(is_finance, TOTAL_WAGES, 0), na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    share_fin = wages_fin / wages_total
  ) %>%
  arrange(year)

# Get peak year
peak_year <- nyc_wage_share$year[which.max(nyc_wage_share$share_fin)]
peak_share <- max(nyc_wage_share$share_fin) * 100

# Create professional gt table
nyc_wage_share %>%
  select(
    Year = year,
    `Total Wages (USD)` = wages_total,
    `Finance & Insurance Wages (USD)` = wages_fin,
    `Finance Share` = share_fin
  ) %>%
  gt() %>%
  tab_options(
    table.width  = gt::pct(100),
    table.align  = "left",    
    heading.align = "left"    
  ) %>%
  tab_header(
    title = md("**Table 6: NYC CBSA — Finance & Insurance Wage Share**"),
    subtitle = "BLS QCEW 2009–2023 • NAICS 52 • 2020 omitted"
  ) %>%
  fmt_currency(
    columns = c(`Total Wages (USD)`, `Finance & Insurance Wages (USD)`),
    decimals = 0
  ) %>%
  fmt_percent(columns = `Finance Share`, decimals = 1) %>%
  cols_align(
    align = "left",
    columns = everything()
  ) %>%
  cols_label(`Finance Share` = "Finance Share of Total") %>%
  tab_style(
    style = list(
      cell_fill(color = "#fff3cd"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(rows = Year == peak_year)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(md("Source: **BLS QCEW**; NAICS 52."))

```

**Answer:** 

**Part A - The Fraction:** Finance and insurance workers earned between **9.4%** and **15.9%** of total wages in the NYC CBSA across the study period.

**Part B - Peak Year:** This fraction **peaked in `r peak_year` at `r round(peak_share, 1)`%**, as highlighted in the table above. The 2021 peak represents a recovery from the declining share observed through the mid-2010s, exceeding even the 2010 post-financial-crisis level (15.4%)

## Task 3: Initial Visualization

### Monthly Rent vs. Average Household Income (2009)

```{r}

#| label: viz-1-rent-income
#| fig-width: 10
#| fig-height: 7

# Prepare data
rent_income_2009 <- RENT %>%
  filter(year == 2009) %>%
  inner_join(INCOME %>% filter(year == 2009), 
             by = c("GEOID", "NAME", "year")) %>%
  select(GEOID, NAME, monthly_rent, household_income) %>%
  mutate(
    state = str_extract(NAME, ", ([A-Z]{2})", group = 1),
    region = case_when(
      state %in% c("CT", "ME", "MA", "NH", "RI", "VT", "NJ", "NY", "PA") ~ "Northeast",
      state %in% c("IL", "IN", "MI", "OH", "WI", "IA", "KS", "MN", "MO", "NE", "ND", "SD") ~ "Midwest",
      state %in% c("DE", "FL", "GA", "MD", "NC", "SC", "VA", "WV", "AL", "KY", "MS", "TN", "AR", "LA", "OK", "TX", "DC") ~ "South",
      state %in% c("AZ", "CO", "ID", "MT", "NV", "NM", "UT", "WY", "AK", "CA", "HI", "OR", "WA") ~ "West",
      state == "PR" ~ "Puerto Rico",
      is.na(state) ~ "Unknown",
      TRUE ~ "Other"
    )
  )

# Create plot
ggplot(rent_income_2009, aes(x = household_income, y = monthly_rent, color = region)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "darkred", linewidth = 1.2) +
  geom_text_repel(
    data = rent_income_2009 %>% 
      filter(NAME %in% c("San Francisco-Oakland-Hayward, CA Metro Area",
                         "New York-Newark-Jersey City, NY-NJ-PA Metro Area",
                         "Miami-Fort Lauderdale-West Palm Beach, FL Metro Area")),
    aes(label = str_remove(NAME, " Metro Area")),
    size = 3,
    box.padding = 0.5,
    point.padding = 0.3,
    segment.color = "gray50"
  ) +
  scale_x_continuous(
    labels = dollar_format(),
    breaks = seq(0, 100000, 20000)
  ) +
  scale_y_continuous(
    labels = dollar_format(),
    breaks = seq(0, 2000, 250)
  ) +
  scale_color_manual(
    name = "Region",
    values = c("Northeast" = "#1f77b4", 
               "Midwest" = "#ff7f0e", 
               "South" = "#2ca02c", 
               "West" = "#d62728",
               "Puerto Rico" = "#9467bd")
  ) +
  guides(color = guide_legend(override.aes = list(size = 4, alpha = 1))) +
  labs(
    title = "How Economic Growth Drives Up Housing Costs",
    subtitle = "Relationship between household income and monthly rent across U.S. metro areas, 2009",
    x = "Average Household Income (USD)",
    y = "Average Monthly Rent (USD)",
    caption = "Source: American Community Survey (ACS), 2009 1-Year Estimates\nNote: Each point represents one Core-Based Statistical Area (CBSA)"
  ) +
  theme_minimal(base_family = "sans", base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", size = 14, margin = margin(b = 5)),
    plot.subtitle = element_text(color = "gray30", size = 11, margin = margin(b = 10)),
    plot.caption = element_text(hjust = 0, face = "italic", color = "gray50", size = 9),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.title = element_text(size = 11, face = "bold"),
    legend.text = element_text(size = 10)
  )

```

This visualization examines whether metropolitan areas with higher household incomes experience proportionally higher rental costs, and how regional patterns differ across the United States in 2009.

## Total Employment vs. Total Employment in Health Care and Social Services

```{r}

#| label: viz-2-healthcare-share
#| fig-width: 10
#| fig-height: 6

# Calculate healthcare share by year
healthcare_share <- WAGES %>%
  mutate(
    year = YEAR,
    is_healthcare = str_starts(as.character(INDUSTRY), "62")
  ) %>%
  group_by(year) %>%
  summarize(
    total_employment = sum(EMPLOYMENT, na.rm = TRUE),
    healthcare_employment = sum(if_else(is_healthcare, EMPLOYMENT, 0), na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(healthcare_share = healthcare_employment / total_employment * 100)

# Create line plot
ggplot(healthcare_share, aes(x = year, y = healthcare_share)) +
  geom_line(color = "steelblue", linewidth = 1.5) +
  geom_point(color = "steelblue", size = 3) +
  geom_area(alpha = 0.2, fill = "steelblue") +
  scale_y_continuous(
    labels = percent_format(scale = 1),
    limits = c(0, NA),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_x_continuous(
    breaks = seq(2009, 2023, 2),
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  labs(
    title = "Healthcare & Social Services as Share of Total Employment",
    subtitle = "Steady growth from 9.3% (2009) to 10.1% (2023), with pandemic-driven acceleration",
    x = "Year",
    y = "Healthcare Share of Total Employment",
    caption = "Source: Bureau of Labor Statistics, Quarterly Census of Employment and Wages (QCEW)\nNAICS 62: Health Care and Social Assistance | 2020 excluded due to COVID-19 data artifacts"
  ) +
  theme_minimal(base_family = "sans", base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", size = 14, margin = margin(b = 5)),
    plot.subtitle = element_text(color = "gray30", size = 11, margin = margin(b = 10)),
    plot.caption = element_text(hjust = 0, face = "italic", color = "gray50", size = 9),
    axis.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )

```

Healthcare and social service jobs grew from 9.3% to 10.1% of all metro employment between 2009 and 2023. This steady growth, which spiked in 2021 due to the pandemic, shows healthcare is an increasing part of the American economy.

### Evolution of Average Household

```{r}

#| label: viz-3-household-size
#| fig-width: 12
#| fig-height: 8

# Step 1: Calculate household size by CBSA and year
household_size_data <- POPULATION %>%
  inner_join(HOUSEHOLDS, by = c("GEOID", "NAME", "year")) %>%
  mutate(
    household_size = population / households,
    state = str_extract(NAME, ", ([A-Z]{2})", group = 1),
    region = case_when(
      state %in% c("CT", "ME", "MA", "NH", "RI", "VT", "NJ", "NY", "PA") ~ "Northeast",
      state %in% c("IL", "IN", "MI", "OH", "WI", "IA", "KS", "MN", "MO", "NE", "ND", "SD") ~ "Midwest",
      state %in% c("DE", "FL", "GA", "MD", "NC", "SC", "VA", "WV", "AL", "KY", "MS", "TN", "AR", "LA", "OK", "TX", "DC") ~ "South",
      state %in% c("AZ", "CO", "ID", "MT", "NV", "NM", "UT", "WY", "AK", "CA", "HI", "OR", "WA") ~ "West",
      state == "PR" ~ "Puerto Rico",
      TRUE ~ "Other"
    )
  ) %>%
  filter(region != "Other", region != "Puerto Rico") %>%
  select(GEOID, NAME, year, household_size, region, population, households)

# Step 2: Calculate regional averages (weighted by population)
regional_averages <- household_size_data %>%
  group_by(region, year) %>%
  summarize(
    avg_household_size = weighted.mean(household_size, w = population, na.rm = TRUE),
    .groups = "drop"
  )

# Step 3: Calculate national average (weighted by population)
national_average <- household_size_data %>%
  group_by(year) %>%
  summarize(
    avg_household_size = weighted.mean(household_size, w = population, na.rm = TRUE),
    region = "National Average",
    .groups = "drop"
  )

# Step 4: Combine for plotting
plot_data <- bind_rows(regional_averages, national_average) %>%
  mutate(
    region = factor(region, 
                   levels = c("National Average", "Northeast", "Midwest", "South", "West"))
  )

# Step 5: Create expanded, properly spaced plot
ggplot(plot_data, aes(x = year, y = avg_household_size, color = region, linetype = region)) +
  geom_line(linewidth = 1.2, alpha = 0.9) +
  geom_point(size = 3, alpha = 0.7) +
  scale_color_manual(
    name = "Region",
    values = c("National Average" = "gray30",
               "Northeast" = "#1f77b4", 
               "Midwest" = "#ff7f0e", 
               "South" = "#2ca02c", 
               "West" = "#d62728")
  ) +
  scale_linetype_manual(
    name = "Region",
    values = c("National Average" = "dashed",
               "Northeast" = "solid",
               "Midwest" = "solid",
               "South" = "solid",
               "West" = "solid")
  ) +
  scale_y_continuous(
    breaks = seq(2.0, 3.5, 0.25),
    limits = c(2.0, 3.5),
    expand = expansion(mult = c(0.05, 0.05))
  ) +
  scale_x_continuous(
    breaks = seq(2009, 2023, 2),
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  labs(
    title = "Evolution of Average Household Size by Region",
    subtitle = "Population-weighted regional averages, 2009-2023",
    x = "Year",
    y = "Average Household Size\n(Persons per Household)",
    caption = "Source: American Community Survey (ACS)\nRegional colors consistent with Visualization 1; national average shown as dashed line"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5, margin = margin(b = 10)),
    plot.subtitle = element_text(size = 12, hjust = 0.5, color = "gray40", margin = margin(b = 20)),
    axis.title.x = element_text(size = 14, face = "bold", margin = margin(t = 15)),
    axis.title.y = element_text(size = 14, face = "bold", margin = margin(r = 20)),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.caption = element_text(size = 10, color = "gray50", hjust = 0, margin = margin(t = 15)),
    legend.position = "right",
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 11),
    legend.key.height = unit(1.5, "cm"),
    legend.key.width = unit(1.5, "cm"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "gray90"),
    plot.margin = margin(20, 25, 20, 20)
  )

```

Nationally, the average household size fell from 2.62 to 2.54 people between 2009 and 2023, a trend seen across all U.S. regions. Regional differences have been consistent: the West has the largest households (2.75 people in 2023), and the Midwest has the smallest (2.45).

This long-term national decline reflects documented demographic and economic factors, including shifts in family structure (<a href="https://usafacts.org/articles/why-are-us-homes-getting-bigger-while-households-shrink/" target="_blank"> such as smaller family sizes</a>) and economic pressures (like housing costs) that influence living arrangements, <a href="https://www.pewresearch.org/short-reads/2025/04/17/the-shares-of-young-adults-living-with-parents-vary-widely-across-the-us/" target="_blank"> especially for young adults</a>.

## Task 4: Rent Burden Analysis

### Changes in Rent Burden Over Time 

```{r}

#| label: task4-rent-burden
#| message: false
#| warning: false

# Part 1: Data Preparation

df_rent_burden <- INCOME %>%
  filter(grepl("Metro Area", NAME)) %>%
  inner_join(
    RENT %>% filter(grepl("Metro Area", NAME)),
    by = c("GEOID", "NAME", "year")
  ) %>%
  filter(year != 2020, household_income > 0, monthly_rent > 0) %>%
  mutate(
    state = str_extract(NAME, ", ([A-Z]{2})", group = 1)
  ) %>%
  filter(state != "PR") %>%  # Exclude Puerto Rico
  mutate(
    monthly_income = household_income / 12,
    rent_to_income_ratio = monthly_rent / monthly_income,
    affordability_gap_pp = (rent_to_income_ratio - 0.30) * 100,
    rti_pct = rent_to_income_ratio * 100
  ) %>%
  select(GEOID, NAME, state, year, affordability_gap_pp, rti_pct, 
         rent_to_income_ratio, median_rent = monthly_rent, 
         median_income = household_income) %>%
  arrange(NAME, year)

latest_year <- max(df_rent_burden$year)
metro_single <- "Colorado Springs, CO Metro Area"
metro_highest <- "Miami-Fort Lauderdale-West Palm Beach, FL Metro Area"
metro_lowest <- df_rent_burden %>%
  filter(year == latest_year) %>%
  arrange(affordability_gap_pp) %>%
  slice(1) %>%
  pull(NAME)

```

---

To measure housing affordability, an **Affordability Gap** metric calculates how many percentage points a metro area's rent-to-income ratio deviates from the <a href="https://www.huduser.gov/portal/datasets/cp/CHAS/bg_chas.html" target="_blank">30% affordability threshold</a> established by the U.S. Department of Housing and Urban Development (HUD).

**Formula:**

$$\text{Affordability Gap (pp)} = (\text{Rent-to-Income Ratio} - 0.30) \times 100$$

**Metric Interpretation:** 

This metric shows how many percentage points a metro's rent-to-income ratio is above or below the 30% federal affordability standard.

- **Positive values** (e.g., +8.0 pp): Burdened. Rent is 8 points above the 30% limit.
- **Negative values** (e.g., -12.8 pp): Affordable. Rent is 12.8 points below the 30% limit.
- **Zero value** (0.0 pp): At the 30% limit.

The formula is more intuitive than a raw ratio and directly answers the policy question: "How far from the affordability standard is this metro?"

**Metric Justification:** 

This metric measures how many percentage points a city is above or below the 30% HUD threshold, or an official government definition of "affordability." Also:

- Easy to Grasp: It's intuitive. A city at 37% is "7 points" over the line.
- Fair: It treats cities 5 points above the line and 5 points below it equally.
- Directly Comparable: All cities are measured against the same 30% benchmark, unlike a "national average" which changes every year.

Most importantly, this metric makes it easy to answer a simple question: "Is this city affordable?"

**Note:** Analysis covers all U.S. metropolitan areas, excluding Puerto Rico. 2020 data is omitted due to pandemic anomalies.

---

#### **Finding: Deteriorating Affordability in Fast-Growing Southern & Mountain-West Metros**

The metros with the largest rent-burden increases from 2009–2023 cluster in the South and Mountain West, with many appearing from traditional Sunbelt markets. Colorado Springs ranks first, with its affordability cushion narrowing from comfortable to concerning. While still below the 30% HUD threshold, the broader pattern shows historically affordable, fast-growing metros facing increasing affordability pressures.

```{r}

# Table 1: Largest Increases

df_change <- df_rent_burden %>%
  filter(year %in% c(2009, 2023)) %>%
  select(GEOID, NAME, state, year, affordability_gap_pp) %>%
  pivot_wider(names_from = year, values_from = affordability_gap_pp, 
              names_prefix = "gap_") %>%
  mutate(change_pp = gap_2023 - gap_2009) %>%
  filter(!is.na(change_pp))

df_table1 <- df_change %>%
  arrange(desc(change_pp)) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Gap 2009 (pp)` = round(gap_2009, 1),
    `Gap 2023 (pp)` = round(gap_2023, 1),
    `Change (pp)` = round(change_pp, 1)
  )

datatable(
  df_table1,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 1: Top 5 Metro Areas with Largest Rent Burden Increases (2009-2023)"
  )
) %>%
  formatRound(c("Gap 2009 (pp)", "Gap 2023 (pp)", "Change (pp)"), digits = 1) %>%
  formatStyle(
    "Metro Area",
    target = 'row',
    backgroundColor = styleEqual(metro_single, '#fdebd0'),
    fontWeight = styleEqual(metro_single, 'bold')
  ) %>%
  formatStyle(
    "Change (pp)",
    backgroundColor = styleInterval(c(2, 4, 6), c("#d4edda", "#fff3cd", "#f8d7da", "#f5c6cb"))
  )

```

---

Sunbelt metros face this tightening as a result of several converging factors during the study period.

- Migration Surge: Many high-earning residents migrated to these areas.
- Constrained Supply: Existing housing and zoning rules prevented developers from increasing the supply of new housing.
- Wage Stagnation: Rents rose faster than local wages, widening the affordability gap.

---

#### **Anatomy of a Squeeze: Colorado Springs Rent Burden Evolution**

The Colorado Springs metro experienced the largest sustained increase in rent burden, illustrating how affordability can wane over time.

```{r}

# Table 2: Time Series 

df_table2 <- df_rent_burden %>%
  filter(NAME == metro_single) %>%
  transmute(
    Year = year,
    `Affordability Gap (pp)` = round(affordability_gap_pp, 1),
    `Rent-to-Income Ratio (RTI)` = round(rent_to_income_ratio, 2),
    `Median Rent ($)` = round(median_rent, 0),
    `Median Income ($)` = round(median_income, 0)
  )

datatable(
  df_table2,
  rownames = FALSE,
  options = list(
    pageLength = 15,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    paste("Table 2: Rent Burden Over Time —", metro_single, "(2009-2023)")
  )
) %>%
  formatRound(c("Affordability Gap (pp)", "Rent-to-Income Ratio (RTI)"), digits = 1) %>%
  formatCurrency(c("Median Rent ($)", "Median Income ($)"), currency = "$", digits = 0) %>%
  formatStyle(
    "Affordability Gap (pp)",
    backgroundColor = styleInterval(
      cuts = c(-10, 0, 10),
      values = c("#d4edda", "#fff3cd", "#f8d7da", "#f5c6cb")
    )
  )
```

---

#### **Context: National Rent Burden Extremes**

While Colorado Springs is on a slippery path, it's still more affordable than metros on the edge of an affordability gap like Florida (as shown in Table 3). However, this metro is catching up fast. It has already lost 5.6 points of affordability since 2009. If this trend continues, it will become another unaffordable metro within the next two decades.

Table 3 highlights that metros with rapid growth lacking sufficient building can lead to potential affordability gaps.

```{r}

# Table 3: Highest Burden

df_table3 <- df_rent_burden %>%
  filter(year == latest_year) %>%
  arrange(desc(affordability_gap_pp)) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Affordability Gap (pp)` = round(affordability_gap_pp, 1),
    `RTI (%)` = round(rti_pct, 1),
    `Median Rent ($)` = round(median_rent, 0),
    `Median Income ($)` = round(median_income, 0)
  )

datatable(
  df_table3,
    rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = TRUE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    HTML(paste0("Table 3: Top 5 Highest Rent Burden Metro Areas — ", latest_year, 
        "<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>",
        "Note: Cape Coral-Fort Myers and Miami are statistically tied at 0.1 pp above the affordability threshold (both 30.1% RTI). ",
        "Miami is highlighted due to its larger population (6.1M vs 830K) and greater policy significance.</span>"))
  )
) %>%
  formatRound(c("Affordability Gap (pp)", "RTI (%)"), digits = 1) %>%
  formatCurrency(c("Median Rent ($)", "Median Income ($)"), currency = "$", digits = 0) %>%
  formatStyle(
    "Metro Area",
    target = 'row',
    backgroundColor = styleEqual(metro_highest, '#fff3cd'),
    fontWeight = styleEqual(metro_highest, 'bold')
  ) %>%
  formatStyle(
    "Affordability Gap (pp)",
    backgroundColor = styleInterval(0, c("#d4edda", "#f8d7da"))
  )

```

---

In different parts of the country, affordability is much stronger, with smaller Midwest/Plains metros, like Bismarck, with other metros like Jefferson City, Decatur, Dubuque, and Paducah close behind. Each of these metros are comfortably below the 30% rent standard, signaling real affordability relief compared with tighter Sunbelt markets.

```{r}

# Table 4: Lowest Burden

df_table4 <- df_rent_burden %>%
  filter(year == latest_year) %>%
  arrange(affordability_gap_pp) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Affordability Gap (pp)` = round(affordability_gap_pp, 1),
    `RTI (%)` = round(rti_pct, 1),
    `Median Rent ($)` = round(median_rent, 0),
    `Median Income ($)` = round(median_income, 0)
  )

datatable(
  df_table4,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    paste("Table 4: Top 5 Lowest Rent Burden Metro Areas —", latest_year)
  )
) %>%
  formatRound(c("Affordability Gap (pp)", "RTI (%)"), digits = 1) %>%
  formatCurrency(c("Median Rent ($)", "Median Income ($)"), currency = "$", digits = 0) %>%
  formatStyle(
    "Metro Area",
    target = 'row',
    backgroundColor = styleEqual(metro_lowest, '#d4edda'),
    fontWeight = styleEqual(metro_lowest, 'bold')
  ) %>%
  formatStyle(
    "Affordability Gap (pp)",
    backgroundColor = styleInterval(0, c("#d4edda", "#f8d7da"))
  )

```

---

By establishing how to measure rent burden, the next section focuses on the supply side of the affordability equation by addressing how intensively metros are building housing.

---

## Task 5: Housing Growth

```{r}

#| label: task5-housing-data-prep
#| code-fold: true
#| code-summary: "Show code"
#| output: false
#| message: false
#| warning: false

# Step 1: Prepare Population Data 

pop_metro <- POPULATION %>%
  filter(grepl("Metro Area", NAME)) %>%
  mutate(
    CBSA = as.numeric(str_extract(GEOID, "[0-9]+$")),
    state = str_extract(NAME, ", ([A-Z]{2})", group = 1)
  ) %>%
  filter(state != "PR") %>%
  select(GEOID, NAME, CBSA, state, year, population)


# Step 2: Join with PERMITS

housing_data <- pop_metro %>%
  inner_join(
    PERMITS %>% rename(permits = new_housing_units_permitted),
    by = c("CBSA", "year")
  ) %>%
  arrange(NAME, year)

# Step 3: Calculate Five-Year Rolling Population Growth

housing_data <- housing_data %>%
  group_by(GEOID, NAME, CBSA) %>%
  arrange(year) %>%
  mutate(
    pop_5yr_ago = lag(population, n = 5),
    pop_change_5yr = population - pop_5yr_ago,
    pop_growth_rate_5yr = (population - pop_5yr_ago) / pop_5yr_ago * 100,
    is_growing = pop_change_5yr > 0
  ) %>%
  ungroup() %>%
  filter(year >= 2014, !is.na(pop_change_5yr))
```

```{r}

#| label: task5-metrics-calculation
#| code-fold: true
#| code-summary: "Show code"
#| output: false
#| message: false
#| warning: false

# Metric 1: Instantaneous Housing Supply 

housing_data <- housing_data %>%
  mutate(
    permits_per_1000 = (permits / population) * 1000
  )

national_avg_metric1 <- housing_data %>%
  group_by(year) %>%
  summarize(
    nat_avg_permits_per_1000 = weighted.mean(permits_per_1000, 
                                             w = population, 
                                             na.rm = TRUE),
    .groups = "drop"
  )

housing_data <- housing_data %>%
  left_join(national_avg_metric1, by = "year") %>%
  mutate(
    metric1_index = (permits_per_1000 / nat_avg_permits_per_1000) * 100
  )

# Metric 2: Growth Acoommodation Index

IDEAL_HOUSEHOLD_SIZE <- 2.5
IDEAL_PERMITS_PER_CAPITA <- 1 / IDEAL_HOUSEHOLD_SIZE

housing_data <- housing_data %>%
  mutate(
    permits_per_pop_growth = if_else(
      is_growing & pop_change_5yr > 100,
      permits / pop_change_5yr,
      NA_real_
    ),
    metric2_index = if_else(
      !is.na(permits_per_pop_growth),
      (permits_per_pop_growth / IDEAL_PERMITS_PER_CAPITA) * 100,
      NA_real_
    )
  )


# Composite Score

housing_data <- housing_data %>%
  mutate(
    composite_score = case_when(
      !is.na(metric2_index) ~ 0.6 * metric1_index + 0.4 * metric2_index,
      !is.na(metric1_index) ~ metric1_index,
      TRUE ~ NA_real_
    )
  )

```

---

Two complementary metrics can best assess housing supply across U.S. metros areas: current per-capita building rate and responsiveness to population growth.

#### **Instantaneous Housing Supply Index (Metric 1)**

This metric shows how intensively a metro is currently building, focusing on permits issued relative to its present rising or falling population. It reflects the metro’s near-term commitment to expanding supply.

**Calculation:**

* Per-capita permitting rate: 

$$\text{Permits per 1,000} = \frac{\text{Total Housing Permits}}{\text{Population}} \times 1,000$$

* Index (national baseline = 100): Divide each metro’s rate by the same-year, population-weighted national average, then multiply by 100.

$$\text{Metric 1 Index} = \frac{\text{Metro's Permits per 1,000}}{\text{National Average Permits per 1,000}} \times 100$$

**Interpretation:**

- **Index = 100**: Building at the national average rate
- **Index > 100**: Building faster than average (e.g., 150 = 50% above average)
- **Index < 100**: Building less than average (e.g., 75 = 25% below average)

For example, a metro with an index of 200 is issuing housing permits at twice the national per-capita rate, indicating fast housing supply expansion.

---

#### **Growth Accommodation Index (Metric 2)**

This metric measures whether a metro is permitting enough new homes to keep pace with five-year population growth.

**Calculation:**

- Permits per growth resident:

$$\text{Permits per Growth} = \frac{\text{Annual Housing Permits}}{\text{Five-Year Population Change}}$$

- Index (ideal baseline = 100): Compare to the ideal 0.4 units per new resident or ~2.5 persons per household (<a href="https://usafacts.org/articles/why-are-us-homes-getting-bigger-while-households-shrink/" target="_blank">U.S. Census Bureau, 2023</a>). 

$$\text{Metric 2 Index} = \frac{\text{Permits per Growth}}{0.4} \times 100$$

**Interpretation:**

- **Index = 100**: building on pace with growth
- **Index > 100**: Surplus housing relative to growth
- **Index < 100**: Deficit housing relative to growth

**Metric Note:** This metric is not applicable to metros with declining or stable populations (defined as five-year population change ≤ 100 people). For these metros, Metric 2 is recorded as NA, and their composite score is based solely on Metric 1.

**Data Note:** Population growth includes both net migration and natural increase (births minus deaths). Housing demand is typically higher when there are higher levels of inward migration, as new households form immediately, compared to natural increase where housing needs develop gradually as families expand. Consequently, Metric 2 might make a metro's housing supply look fine if its population growth is mostly from births, even if it's not building enough.

---

#### **Composite Housing Growth Score**

A single score that blends current building effort (Metric 1) and growth responsiveness (Metric 2):

$$\text{Composite Score} = (0.6 \times \text{Metric 1}) + (0.4 \times \text{Metric 2})$$

- **Justification for 60/40**: Most residents are current households, so steady per-capita building should carry slightly more weight than growth-driven need; thus, rewarding metros that keep up with population gains.

- **Special Case for No Growth**: If five-year population change ≤ 100 (Metric 2 = NA), the Composite = Metric 1.

---

#### **Strategic Design Choices**

- Population-weighted baseline: National averages are weighted by population, thus the “100” benchmark reflects where most people live.
- Five-year window: Matches <a href="https://www.census.gov/content/dam/Census/library/publications/2018/acs/acs_general_handbook_2018_ch03.pdf" target="_blank">typical housing/ACS five-year cycles<a/>, smoothing year-to-year noise.
- Household size anchor: Uses ~2.5 persons/household ⇒ 0.4 units per new resident as the “on-pace” benchmark for Metric 2.
- Robustness: Results are stable under other nearby weights (e.g., 50/50 or 70/30); therefore, rankings move little, confirming the composite isn’t overly sensitive.

---

#### **Robustness Check: Alternative Weighting Scenarios**

Testing different formulas shows the same five metros consistently at the Top 5, but rankings within this group shift drastically. 

---

```{r}

#| label: task5-sensitivity-analysis
#| code-fold: true
#| code-summary: "Show code"

# Calculate alternative composite scores
sensitivity_2023 <- housing_data %>%
  filter(year == 2023, !is.na(metric2_index)) %>%
  mutate(
    composite_50_50 = 0.5 * metric1_index + 0.5 * metric2_index,
    composite_70_30 = 0.7 * metric1_index + 0.3 * metric2_index
  ) %>%
  arrange(desc(composite_score)) %>%
  slice_head(n = 5) %>%
  transmute(
    Metro = str_remove(NAME, "\\s*Metro Area$"),
    `60/40 (Current)` = round(composite_score, 1),
    `50/50` = round(composite_50_50, 1),
    `70/30` = round(composite_70_30, 1),
    `Max Difference` = round(pmax(
      abs(composite_score - composite_50_50),
      abs(composite_score - composite_70_30)
    ), 1)
  )

# ---- gt table ----
sensitivity_2023 %>%
  gt() %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(16)
  ) %>%
  tab_header(
    title = md("**Robustness Check — Alternative Weighting Scenarios (2023 Top 5)**"),
    subtitle = "Top 5 metros ranked by current 60/40 composite score"
  ) %>%
  opt_row_striping() %>%  
  cols_label(
    Metro = "Metro",
    `60/40 (Current)` = "60/40 (Current)",
    `50/50` = "50/50",
    `70/30` = "70/30",
    `Max Difference` = "Max Difference"
  ) %>%
  fmt_number(
    columns = c(`60/40 (Current)`, `50/50`, `70/30`, `Max Difference`),
    decimals = 1,
    use_seps = TRUE
  ) %>%
  cols_align(
    align = "left",
    columns = everything()
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(
    md(paste0(
      "**Source.** Census Building Permits Survey, ACS Population estimates, 2023. "))
  )
  
```

---

**Urban Honolulu** metro shows a **114.2-point swing** between 50/50 (325.1) and 70/30 (210.9) weighting and has the largest sensitivity in this cohort. Although Honolulu excels at building for new arrivals (Metric 2) it falls extremely short for existing residents (Metric 1). The 50/50 weighting wrongly highlights this metro as a top performer despite neglecting the housing needs of its current residents. 

Therefore, the **60/40** weight is the best option as it accurately reflects resident composition. Most of the analzyed metros consist of existing households needing stable supply, with population growth impacting a smaller share annually. This weighted balance recognizes and awards metros like Punta Gorda that are consistently building for *all* residents.

---

```{r}

#| label: task5-tables-metric1
#| code-fold: true
#| code-summary: "Show code for Metric 1 analysis"

metrics_2023 <- housing_data %>%
  filter(year == 2023)

# Table 1a: Top 5 - Metric 1

table1_high <- metrics_2023 %>%
  arrange(desc(metric1_index)) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Index` = round(metric1_index, 1),
    `Permits per 1,000` = round(permits_per_1000, 2),
    `Total Permits` = scales::comma(permits),
    `Population (M)` = round(population / 1e6, 2)
  )

datatable(
  table1_high,
   rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 1a: Top 5 Metros — Instantaneous Housing Supply Index (2023)"
  )
) %>%
  formatStyle(
    "Index",
    backgroundColor = styleInterval(c(150, 250, 350), 
                                   c("#ffffff", "#d4edda", "#c3e6cb", "#a8d5ba"))
  )
```

---
```{r}

#| code-fold: true
#| code-summary: "Show code"

# Table 1B: Bottom 5 - Metric 1

table1_low <- metrics_2023 %>%
  arrange(metric1_index) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Index` = round(metric1_index, 1),
    `Permits per 1,000` = round(permits_per_1000, 2),
    `Total Permits` = scales::comma(permits),
    `Population (M)` = round(population / 1e6, 2)
  )

datatable(
  table1_low,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 1b: Bottom 5 Metros — Instantaneous Housing Supply Index (2023)"
  )
) %>%
  formatStyle(
    "Index",
    backgroundColor = styleInterval(c(10, 25, 50), 
                                   c("#f5c6cb", "#f8d7da", "#fff3cd", "#ffffff"))
  )
```

---
```{r}

#| label: task5-tables-metric2
#| code-fold: true
#| code-summary: "Show code for Metric 2 analysis"

# Table 2A: Top 5 - Metric 2

table2_high <- metrics_2023 %>%
  filter(!is.na(metric2_index)) %>%
  arrange(desc(metric2_index)) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Index` = round(metric2_index, 1),
    `Permits per Growth` = round(permits_per_pop_growth, 3),
    `5yr Pop Growth` = scales::comma(pop_change_5yr),
    `Total Permits` = scales::comma(permits)
  )

datatable(
  table2_high,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 2a: Top 5 Metros — Growth Accommodation Index (2023)"
  )
) %>%
  formatStyle(
    "Index",
    backgroundColor = styleInterval(c(100, 200, 400), 
                                   c("#ffffff", "#d4edda", "#c3e6cb", "#a8d5ba"))
  )

```

---
```{r}

#| code-fold: true
#| code-summary: "Show code"

# TABLE 2B: Bottom 5 - Metric 2

table2_low <- metrics_2023 %>%
  filter(!is.na(metric2_index)) %>%
  arrange(metric2_index) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Index` = round(metric2_index, 1),
    `Permits per Growth` = round(permits_per_pop_growth, 3),
    `5yr Pop Growth` = scales::comma(pop_change_5yr),
    `Total Permits` = scales::comma(permits)
  )

datatable(
  table2_low,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 2b: Bottom 5 Metros — Growth Accommodation Index (2023)"
  )
) %>%
  formatStyle(
    "Index",
    backgroundColor = styleInterval(c(5, 10, 25), 
                                   c("#f5c6cb", "#f8d7da", "#fff3cd", "#ffffff"))
  )
```

---
```{r}

#| label: task5-tables-composite
#| code-fold: true
#| code-summary: "Show code for Composite Score analysis"

# Table 3A: Top 5 - Composite Score

table3_high <- metrics_2023 %>%
  filter(!is.na(composite_score)) %>%
  arrange(desc(composite_score)) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Composite Score` = round(composite_score, 1),
    `Metric 1` = round(metric1_index, 1),
    `Metric 2` = round(metric2_index, 1),
    `Population (M)` = round(population / 1e6, 2)
  )

datatable(
  table3_high,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 3a: Top 5 Metros — Composite Housing Growth Score (2023)",
    HTML("<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>
         Composite = 60% Instantaneous Index + 40% Growth Accommodation Index</span>")
  )
) %>%
  formatStyle(
    "Composite Score",
    backgroundColor = styleInterval(c(150, 225, 300), 
                                   c("#ffffff", "#d4edda", "#c3e6cb", "#a8d5ba"))
  )
```

---
```{r}

#| code-fold: true
#| code-summary: "Show code"

# Table 3B: Bottom 5 - Composite Score

table3_low <- metrics_2023 %>%
  filter(!is.na(composite_score)) %>%
  arrange(composite_score) %>%
  head(5) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `Composite Score` = round(composite_score, 1),
    `Metric 1` = round(metric1_index, 1),
    `Metric 2` = if_else(!is.na(metric2_index), as.character(round(metric2_index, 1)), "—"),
    `Population (M)` = round(population / 1e6, 2)
  )

datatable(
  table3_low,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 't', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 3b: Bottom 5 Metros — Composite Housing Growth Score (2023)",
    HTML("<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>
         Composite = 60% Instantaneous Index + 40% Growth Accommodation Index (or Metric 1 only if declining)</span>")
  )
) %>%
  formatStyle(
    "Composite Score",
    backgroundColor = styleInterval(c(5, 15, 30), 
                                   c("#f5c6cb", "#f8d7da", "#fff3cd", "#ffffff"))
  )

```

---

Several metros in Tables 3a and 3b show "—" or "Not Applicable" for Metric 2. This occurs when five-year population change is ≤100 people, indicating overall stability or decline. For these metros:

- **There is no growth to accommodate**, making a "permits per new resident" ratio meaningless.
- **Their Composite Score = Metric 1 only**, reflecting how they're building relative to their current population.
- **This is not a flaw** as it correctly recognizes that metros losing population face different housing challenges than booming metros.

The table below shows the 10 metros with the most substantial population decline, illustrating why Metric 2 cannot apply.

---

```{r}

#| label: task5-declining-metros
#| code-fold: true
#| code-summary: "Show code for declining metros analysis"
#| message: false
#| warning: false

# Explanatory Table: Declining Metros 

declining_explanation <- housing_data %>%
  filter(year == 2023) %>%
  arrange(pop_change_5yr) %>%
  head(10) %>%
  transmute(
    Rank = row_number(),
    `Metro Area` = NAME,
    State = state,
    `5yr Pop Change` = scales::comma(pop_change_5yr),
    `Growth Rate (%)` = round(pop_growth_rate_5yr, 1),
    `Metric 2 Status` = if_else(is.na(metric2_index), "Not Applicable", "Calculated"),
    `Metric 1 Index` = round(metric1_index, 1)
  )

datatable(
  declining_explanation,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 'ltp', 
    ordering = TRUE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Supplemental Table: Metros with Declining or Minimal Population Growth (2018-2023)",
    HTML("<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>
         Metric 2 (Growth Accommodation Index) is not applicable for metros with declining or negligible growth,
         as there is no population increase to accommodate. These metros are evaluated solely on Metric 1.</span>")
  )
) %>%
  formatStyle(
    "5yr Pop Change",
    backgroundColor = styleInterval(c(-5000, 0, 500), 
                                   c("#f5c6cb", "#f8d7da", "#fff3cd", "#ffffff"))
  )
```

---

Defining rent burden (Task 4) and housing growth (Task 5) metrics, the next section explores identifying the metros that successfully addressed affordability challenges through sustained construction.

---

## Task 6: Rent Burden and Housing Growth Relationships

```{r}

#| label: task6-data-prep
#| code-fold: true
#| code-summary: "Show code"
#| output: false
#| message: false
#| warning: false

# Data Preparation

rent_burden_periods <- df_rent_burden %>%
  mutate(
    period = case_when(
      year >= 2014 & year <= 2016 ~ "early",
      year >= 2021 & year <= 2023 ~ "late",
      TRUE ~ "middle"
    )
  ) %>%
  filter(period %in% c("early", "late")) %>%
  group_by(GEOID, NAME, state, period) %>%
  summarize(avg_gap = mean(affordability_gap_pp, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = period, values_from = avg_gap, names_prefix = "gap_") %>%
  mutate(rent_burden_change = gap_late - gap_early)

housing_2023 <- housing_data %>%
  filter(year == 2023) %>%
  select(GEOID, NAME, state, composite_score, pop_change_5yr, is_growing, population, pop_5yr_ago)

combined_analysis <- rent_burden_periods %>%
  inner_join(housing_2023, by = c("GEOID", "NAME", "state")) %>%
  filter(!is.na(composite_score), !is.na(rent_burden_change)) %>%
  mutate(
    pop_growth_rate = (pop_change_5yr / pop_5yr_ago) * 100
  )

early_burden_threshold <- quantile(combined_analysis$gap_early, 0.75, na.rm = TRUE)

combined_analysis <- combined_analysis %>%
  mutate(
    criterion1 = gap_early > early_burden_threshold,
    criterion2 = rent_burden_change < 0,
    criterion3 = is_growing & pop_change_5yr > 0,
    criterion4 = composite_score > 100,
    yimby_score = criterion1 + criterion2 + criterion3 + criterion4
  )

```

---

### **YIMBY Success Identification**

We classify “YIMBY success” as metros who meet **four** special criteria, where aggressive building successfully reduces housing costs despite growing population demands.  

- **Criteria 1 (C1)**: High early rent burden (top 25%; threshold = `r round(early_burden_threshold, 1)` percentage points [pp] above 30%),  
- **Criteria 1 (C2)**: Rent burden improved (2021–2023 avg < 2014–2016 avg),  
- **Criteria 1 (C3)**: (positive five-year change, 2018–2023), and  
- **Criteria 1 (C4)**: Above-average housing growth (composite > 100).

*Time Periods*: Early = 2014–2016; Late = 2021–2023.

---

### **Key Findings: YIMBY Success Summary**

```{r}

#| label: task6-summary
#| code-fold: true
#| code-summary: "Show code"

# Calculate summary statistics
total_metros <- nrow(combined_analysis)
success_4of4 <- sum(combined_analysis$yimby_score == 4, na.rm = TRUE)
success_3of4 <- sum(combined_analysis$yimby_score == 3, na.rm = TRUE)
avg_change_4of4 <- mean(combined_analysis$rent_burden_change[combined_analysis$yimby_score == 4], na.rm = TRUE)
avg_change_3of4 <- mean(combined_analysis$rent_burden_change[combined_analysis$yimby_score == 3], na.rm = TRUE)

```

The analysis of **`r total_metros` metropolitan areas** reveals compelling evidence for YIMBY policy effectiveness:

- **Complete YIMBY success (4/4):** `r success_4of4` metros; average rent burden change **`r round(abs(avg_change_4of4), 1)` pp** (better).  
- **Strong performance (3/4):** `r success_3of4` metros; average rent burden change **`r round(avg_change_3of4, 1)` pp**.

These metros demonstrate that sustained, above-average housing construction can successfully reduce rent burden even in rapidly growing markets.

---

### **Complete YIMBY Success: Metros Meeting All 4 Criteria**

```{r}

#| label: task6-table-4of4
#| code-fold: true
#| code-summary: "Show code"

yimby_4of4 <- combined_analysis %>%
  filter(yimby_score == 4) %>%
  arrange(desc(composite_score)) %>%
  transmute(
    Rank = row_number(),
    Metro = str_remove(NAME, " Metro Area"),
    State = state,
    `Early Burden` = round(gap_early, 1),
    `Burden Change` = round(rent_burden_change, 1),
    `Pop Growth (%)` = round(pop_growth_rate, 1),
    `Housing` = round(composite_score, 1)
  )

datatable(
  yimby_4of4,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 'ltp', 
    ordering = TRUE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all'),
      list(width = '200px', targets = 1),
      list(width = '50px', targets = 2),
      list(width = '90px', targets = 3:6)
    )
  ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 1: Complete YIMBY Success (4/4 Criteria)",
    HTML("<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>
         Metros meeting all four criteria: high early burden, improved, growing, and high housing growth</span>")
  )
) %>%
  formatStyle(
    columns = c(1:7),
    backgroundColor = "#e8f5e9"
  ) %>%
  formatStyle(
    "Burden Change",
    color = "darkgreen",
    fontWeight = "bold"
  )

```

---

### **Strong Performance: Metros Meeting 3 of 4 Criteria**
```{r}

#| label: task6-table-3of4
#| code-fold: true
#| code-summary: "Show code"

yimby_3of4 <- combined_analysis %>%
  filter(yimby_score == 3) %>%
  arrange(desc(composite_score)) %>%
  mutate(
    missing_criterion = case_when(
      !criterion1 ~ "C1",
      !criterion2 ~ "C2",
      !criterion3 ~ "C3",
      !criterion4 ~ "C4",
      TRUE ~ "—"
    )
  ) %>%
  transmute(
    Rank = row_number(),
    Metro = str_remove(NAME, " Metro Area"),
    State = state,
    Missing = missing_criterion,
    `Early` = round(gap_early, 1),
    `Burden Change` = round(rent_burden_change, 1),
    `Pop Growth (%)` = round(pop_growth_rate, 1),
    `Housing` = round(composite_score, 1)
  )

datatable(
  yimby_3of4,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 'ltp', 
    ordering = TRUE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all'),
      list(width = '180px', targets = 1),
      list(width = '50px', targets = 2),
      list(width = '60px', targets = 3),
      list(className = 'dt-center', targets = 3),
      list(width = '80px', targets = 4:7)
    )
  ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 2: Strong Performance (3/4 Criteria)",
    HTML("<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>
         Missing: C1 = High early burden | C2 = Improved | C3 = Growing | C4 = High housing</span>")
  )
) %>%
  formatStyle(
    columns = c(1:8),
    backgroundColor = "#f1f8e9"
  ) %>%
  formatStyle(
    "Burden Change",
    color = styleInterval(0, c("darkgreen", "darkred"))
  ) %>%
  formatStyle(
    "Missing",
    backgroundColor = "#fff3cd"
  )
```

---

### **Visualization 1: The Core Relationship**

This interactive scatterplot reveals the relationship between housing construction intensity and rent burden outcomes among YIMBY success candidates (3/4 and 4/4 metros only). **Hover over bubbles to see metro details**.

```{r}

#| label: task6-plot1
#| code-fold: true
#| code-summary: "Show code"
#| fig.width: 12
#| fig.height: 9
#| warning: false

# Background layer: ALL metros (for context)
background_data <- combined_analysis %>%
  mutate(
    metro_clean = str_remove(NAME, " Metro Area"),
    yimby_category = "0-2/4 (Other)",
    hover_text = paste0(
      "<b>", metro_clean, "</b><br>",
      "YIMBY Score: ", yimby_score, "/4<br>",
      "Housing Score: ", round(composite_score, 1), "<br>",
      "Burden Change: ", round(rent_burden_change, 1), " pp"
    )
  )

# Foreground layer: Only 3/4 and 4/4 metros (success stories)
plot_data <- combined_analysis %>%
  filter(yimby_score >= 3) %>%
  mutate(
    metro_clean = str_remove(NAME, " Metro Area"),
    score_label = paste0(yimby_score, "/4"),
    yimby_category = if_else(yimby_score == 4, "4/4 (Complete)", "3/4 (Strong)"),
    hover_text = paste0(
      "<b>", metro_clean, "</b><br>",
      "YIMBY Score: ", yimby_score, "/4<br>",
      "Population Growth: ", comma(abs(pop_change_5yr)), "<br>",
      "Housing Score: ", round(composite_score, 1), "<br>",
      "Burden Change: ", round(rent_burden_change, 1), " pp"
    )
  )

# Create ggplot with TWO layers
p <- ggplot() +
  # LAYER 1: Background - all metros in light gray
  geom_point(
    data = background_data,
    aes(x = composite_score, 
        y = rent_burden_change,
        color = yimby_category,
        text = hover_text),
    size = 2,
    alpha = 0.4
  ) +
  
  # Reference lines
  geom_hline(yintercept = 0, color = "gray30", linewidth = 0.8) +
  geom_vline(xintercept = 100, color = "gray30", linewidth = 0.8) +
  
  # Shaded success quadrant (LOWER-RIGHT = Q4)
  annotate("rect", xmin = 100, xmax = Inf, ymin = -Inf, ymax = 0,
           alpha = 0.08, fill = "green") +
  
  # Quadrant labels
  annotate("text", x = 220, y = 7, 
           label = "Q1: Growing Pains", 
           size = 3.5, color = "gray40", hjust = 0.5) +
  annotate("text", x = 30, y = 7, 
           label = "Q2: Worst", 
           size = 3.5, color = "gray40", hjust = 0.5) +
  annotate("text", x = 30, y = -7, 
           label = "Q3: Lucky", 
           size = 3.5, color = "gray40", hjust = 0.5) +
  annotate("text", x = 220, y = -7, 
           label = "Q4: YIMBY SUCCESS", 
           size = 4, fontface = "bold", color = "darkgreen", hjust = 0.5) +
  
  # LAYER 2: Foreground - success stories (3/4 and 4/4) in color
  geom_point(
    data = plot_data,
    aes(x = composite_score, 
        y = rent_burden_change,
        color = yimby_category,
        size = abs(pop_change_5yr),
        text = hover_text),
    alpha = 0.8
  ) +
  
  # Color scale - now includes all three categories
  scale_color_manual(
    values = c(
      "0-2/4 (Other)" = "gray85",
      "3/4 (Strong)" = "#a1d99b",
      "4/4 (Complete)" = "#006d2c"
    ),
    name = "YIMBY Score",
    breaks = c("4/4 (Complete)", "3/4 (Strong)", "0-2/4 (Other)")
  ) +
  
  # Size scale (controls visual size, not in legend)
  scale_size_continuous(
    range = c(3, 16),
    guide = "none"
  ) +
  
  # Scales
  scale_x_continuous(
    breaks = seq(0, 310, 50),
    limits = c(0, 310),
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  scale_y_continuous(
    breaks = seq(-10, 10, 2.5),
    limits = c(-10, 10),
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  
  # Labels
  labs(
    title = "Housing Growth vs. Rent Burden Outcomes",
    x = "Housing Growth Composite Score (100 = National Average)",
    y = "Change in Rent Burden (pp), 2023 vs 2014-2016\nNegative = Improvement"
  ) +
  
  # Theme
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    axis.title.x = element_text(size = 11),
    axis.title.y = element_text(size = 11),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 11, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )

# Convert to plotly - it will handle both layers automatically
fig <- ggplotly(p, tooltip = "text") %>%
  layout(
    title = list(
      text = "Housing Growth vs. Rent Burden Outcomes",
      x = 0.5,
      xanchor = "center",
      font = list(size = 17, color = "black")
    ),
    margin = list(t = 90, r = 180, b = 80, l = 90),
    showlegend = TRUE,
    hoverlabel = list(
      bgcolor = "white",
      font = list(size = 13, color = "black"),
      bordercolor = "gray",
      align = "left"
    ),
    xaxis = list(
      title = list(
        text = "Housing Growth Composite Score (100 = National Average)",
        font = list(size = 11)
      ),
      tickfont = list(size = 10),
      range = c(0, 310)
    ),
    yaxis = list(
      title = list(
        text = "Change in Rent Burden (pp), 2023 vs 2014-2016<br>Negative = Improvement",
        font = list(size = 11)
      ),
      tickfont = list(size = 10)
    ),
    legend = list(
      x = 1.02,
      y = 0.98,
      xanchor = "left",
      yanchor = "top",
      font = list(size = 11),
      bgcolor = "rgba(255,255,255,0.9)",
      bordercolor = "lightgray",
      borderwidth = 1
    )
  ) %>%
  config(
    displayModeBar = TRUE,
    modeBarButtonsToRemove = c("select2d", "lasso2d", "toggleSpikelines"),
    displaylogo = FALSE
  )

fig

```

**Notes** 

- **Q1 (upper-right)**: Building but burden rising
- **Q2 (upper-left)**: Low building + Worsening
- **Q3 (lower-left)**: Improving without building 
- **Q4 (lower-right)**: YIMBY SUCCESS (High building + Improving)
- **Circle** size represents absolute population growth 2018-2023. Larger circles imply higher population growth.
- **Periods**: Early = 2014-2016 avg, Late = 2021-2023 avg.

---

#### **The Q3 Quandary: Improving Without Building**

Some metros became more affordable without building new homes, but this wasn't circumstance. It occured due to two factors: 

- **Population Loss**:  Metros like those in the Rust Belt lost residents, reducing housing demand. (Note: These metros technically fail C3 and should not appear in the 3/4 or 4/4 groups under analysis.)
- **Wages Increased**: A few metros had sudden industry surges (like energy), raising salaries faster than rent, but these gains are volatile and sector-specific.

However, these outcomes are unrealistic. A growing metro can't gamble on "losing people" to address housing issues. For metros experience population influxes, building more remains the only feasible solution. Therefore, Q4 (YIMBY success—building metros) remains the only sustainable model for identified growth metros.

---

### **Visualization 2: Distribution by Criteria Met**

This boxplot shows how rent burden change varies by the number of YIMBY criteria met across all metros.

```{r}

#| label: task6-plot2
#| code-fold: true
#| code-summary: "Show code"
#| fig.width: 10
#| fig.height: 6
#| warning: false

# Calculate summary statistics for labels
summary_by_score <- combined_analysis %>%
  group_by(yimby_score) %>%
  summarize(
    n = n(),
    median_change = median(rent_burden_change, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    yimby_label = paste0(yimby_score, "/4\n(n=", n, ")")
  )

# Create boxplot
ggplot(combined_analysis, aes(x = factor(yimby_score), y = rent_burden_change)) +
  geom_boxplot(
    aes(fill = factor(yimby_score)),
    alpha = 0.7,
    outlier.alpha = 0.3,
    outlier.size = 1.5
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8) +
  
  # Add median value labels
  stat_summary(
    fun = median,
    geom = "text",
    aes(label = round(after_stat(y), 1)),
    size = 3.5,
    fontface = "bold",
    vjust = -0.5
  ) +
  
  scale_fill_manual(
    values = c(
      "4" = "#006d2c",  # Rich dark green
      "3" = "#a1d99b",  # Soft light green
      "2" = "#fee090",
      "1" = "#fc8d59",
      "0" = "#d73027"
    ),
    guide = "none"
  ) +
  scale_x_discrete(
    labels = summary_by_score$yimby_label
  ) +
  labs(
    title = "Rent Burden Change by YIMBY Criteria Met",
    subtitle = "Distribution of burden change for metros meeting 0-4 criteria | Numbers show median values\nDashed red line at 0 = no change | Negative values = improvement",
    x = "YIMBY Score (number of criteria met)",
    y = "Change in Rent Burden (pp), 2023 vs 2014-2016\nNegative = Improvement",
    caption = "Box shows interquartile range; whiskers extend to 1.5×IQR\nHigher YIMBY scores correlate with greater rent burden improvements"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 13),
    panel.grid.major.x = element_blank()
  )

```

---

### **Interpretation and Policy Implications**

Across the sample, 12 metros meeting all 4 criteria cut rent burden by ~1.4 pp between 2014–2016 and 2021–2023 despite population growth. As a result, there is clear evidence that sustained building can relieve affordability pressure.

**The Data Story**

- **Where it works**: Success clusters in the Southeast/Sunbelt and a few high-growth markets, with faster permitting and fewer density constraints.
- **More criteria, bigger gains**: The more YIMBY criteria a metro meets, the larger the burden improvement; 4/4 metros outperform lower scorers.
- **Mechanism**: “Q4” metros (high building + improving burden) absorbed growth without proportional rent increases.
- **Timing**: Gains materialize over ~7–9 years, and likely compound with continued permitting.

The policy implication is clear: regulatory reform that enables sustained construction may lead to improved affordability within a 7-9 year timeframe.

---

## Task 7: Policy Brief - Sponsor City Selection

### Primary Sponsor: YIMBY Success City

Building on Task 6 outcomes,**Punta Gorda, FL** is the flagship YIMBY success story. This metro meets all four YIMBY tests: high early burden, burden fell (-0.3 pp), strong growth (+13.2%), and nation-leading building (housing index ~292). 

A key takeaway is that when metros build at scale, they can grow and keep rents in check.

---

### Co-Sponsor: Opportunity City Selection

To identify optimal co-sponsor cities, analysis refinements are necessary to target metros exhibiting the inverse pattern, specifically fast-growing metros with reduced affordability and lagging construction lags. A simple three-part test will seek to uncover:

- Population growth (real demand),
- Burden flat/worse (no relief), and
- Below-average building (under-supply).

Metros that exhibit these indicators are on a potential path to crisis, making them the best candidates for a federal YIMBY incentive to enhance supply and shift rents down.

```{r}

#| label: task7-nimby-table
#| code-fold: true

# Generate NIMBY candidates (from previous analysis)
nimby_candidates <- combined_analysis %>%
  filter(criterion3 == TRUE) %>%
  filter(criterion2 == FALSE) %>%
  filter(criterion4 == FALSE) %>%
  filter(population >= 500000) %>%
  filter(state != "FL") %>%
  filter(rent_burden_change > 0) %>%
  mutate(
    metro_clean = str_remove(NAME, " Metro Area"),
    current_burden = gap_late,
    pop_millions = population / 1000000
  ) %>%
  arrange(desc(rent_burden_change)) %>%
  select(metro_clean, state, current_burden, rent_burden_change,
         pop_growth_rate, pop_millions, composite_score)

# Display table
display_nimby <- nimby_candidates %>%
  head(10) %>%
  transmute(
    Rank = row_number(),
    Metro = metro_clean,
    State = state,
    `Burden (pp)` = round(current_burden, 1),
    `Worsened (pp)` = round(rent_burden_change, 1),
    `Pop (M)` = round(pop_millions, 1),
    `Growth (%)` = round(pop_growth_rate, 1),
    `Housing` = round(composite_score, 0)
  )

datatable(
  display_nimby,
  rownames = FALSE,
  options = list(
    pageLength = 5,
    dom = 'ltp', 
    ordering = FALSE,
    columnDefs = list(
      list(className = 'dt-left', targets = '_all')
      )
    ),
  caption = tags$caption(
    style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 1.1em;',
    "Table 1: Opportunity Cities: Metros Where Affordability is Worsening",
    HTML("<br><span style='font-size: 0.85em; font-weight: normal; color: #666;'>
         Growing cities with worsening burden and insufficient building | Sorted by magnitude of burden increase | M = Millions</span>")
  )
) %>%
  formatStyle("Worsened (pp)", backgroundColor = "#ffc107", fontWeight = "bold") %>%
  formatStyle("Housing", color = styleInterval(90, c("#dc3545", "#6c757d")))
```

---

**Recommended Co-Sponsor:** **Atlanta, GA Metro** — With 6.3 million residents and 12.4% population growth, this metro highlights a booming area where rent burden worsened by 3.0 pp due to below-average housing construction (score: 84). This profile is highly attractive to a policy bill that can support a metro candidate with federal incentives to unlock housing supply to reduce rents.

---

### Federal YIMBY Bill Proposal: Success Stories vs. Opportunity Cities

```{r}

#| label: task7-side-by-side-comparison
#| code-fold: true

# Data Preparation
yimby_success <- combined_analysis %>%
  filter(yimby_score == 4) %>%
  arrange(desc(composite_score)) %>%
  mutate(
    metro_clean     = str_remove(NAME, " Metro Area"),
    burden_display  = round(rent_burden_change, 1),
    housing_display = round(composite_score, 1)
  ) %>%
  select(metro_clean, state, burden_display, housing_display) %>%
  head(10)

nimby_opportunity <- nimby_candidates %>%
  arrange(desc(rent_burden_change)) %>%
  mutate(
    burden_display  = round(rent_burden_change, 1),
    housing_display = round(composite_score, 0)
  ) %>%
  select(metro_clean, state, burden_display, housing_display) %>%
  head(10)

tbl <- tibble(
  rank                = 1:10,
  success_metro       = paste0(yimby_success$metro_clean, ", ", yimby_success$state),
  burden_change_s     = paste0(yimby_success$burden_display, " pp"),
  housing_s           = yimby_success$housing_display,
  opportunity_metro   = paste0(nimby_opportunity$metro_clean, ", ", nimby_opportunity$state),
  burden_change_o     = paste0("+", nimby_opportunity$burden_display, " pp"),
  housing_o           = nimby_opportunity$housing_display
)

# add star to rank 1 success metro
tbl$success_metro[1] <- paste0(tbl$success_metro[1], " ★")

# ---- render with gt ----
gt_tbl <- tbl %>%
  gt() %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(14)   
  ) %>%
  tab_header(
    title = md("**Table 2: Federal YIMBY Bill Proposal: Rewarding Success, Catalyzing Change**")
  ) %>%
  # Make column headers bold
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) %>%
  # column labels
  cols_label(
    rank              = "Rank",
    success_metro     = "Success Story Metro",
    burden_change_s   = "Burden Change",
    housing_s         = "Housing",
    opportunity_metro = "Opportunity City Metro",
    burden_change_o   = "Burden Change",
    housing_o         = "Housing"
  ) %>%
  # spanners (group headers)
  tab_spanner(
    label = "Grant Recipients (4/4 YIMBY Success)",
    columns = c(success_metro, burden_change_s, housing_s)
  ) %>%
  tab_spanner(
    label = "Priority Cities (Worsening Burden)",
    columns = c(opportunity_metro, burden_change_o, housing_o)
  ) %>%
  # widths
  cols_width(
    rank ~ px(48),
    success_metro ~ px(240),
    c(burden_change_s, housing_s) ~ px(70),
    opportunity_metro ~ px(240),
    c(burden_change_o, housing_o) ~ px(70)
  ) %>%
  # alignment
  cols_align(align = "left", columns = everything()) %>%
  cols_align(align = "center", columns = rank) %>%
  cols_align(align = "left",
             columns = c(burden_change_s, housing_s, burden_change_o, housing_o)) %>%
  # left border before Opportunity columns
  tab_style(
    style = cell_borders(sides = "left", color = "#dee2e6", weight = px(2)),
    locations = list(
      cells_body(columns = opportunity_metro),
      cells_column_labels(columns = opportunity_metro)
    )
  ) %>%
  # row striping
  opt_row_striping() %>%
  # highlight rank 1 row
  tab_style(
    style = list(cell_fill(color = "#d4edda"), cell_text(weight = "bold")),
    locations = cells_body(rows = rank == 1)
  ) %>%
  # light background for spanner row
  tab_style(
    style = cell_fill(color = "#f8f9fa"),
    locations = cells_column_spanners(
      spanners = c("Grant Recipients (4/4 YIMBY Success)",
                   "Priority Cities (Worsening Burden)")
    )
  ) %>%
  # Source note at bottom
  tab_source_note(
    md("**Note:** Burden Change = Change in rent burden (pp), 2023 vs 2014–2016. Negative = improvement. Housing = Composite growth score (100 = national avg).")
  )

gt_tbl


```

**Policy Implication:** : When metros scale building, they can hold rent burden down even while growing (Punta Gorda). Conversely, metros that under-build result in burden increases despite growth (Atlanta). 

A federal YIMBY grant would help “opportunity" metros follow a success path by incentivizing pro-building local reforms and rewarding measurable progress.

## Determining a YIMBY-to-NIMBY Comparison 

A comprehensive review of every major two-digit NAICS sector was necessary to avoid arbitrary selection. The pattern is consistent: rent-sensitive, locally-serving sectors, specifically **Accommodation & Food (NAICS 72)** and **Retail (NAICS 44)**, show the largest ATL-PG rent-share gaps, while high-wage tradables show little or no difference. These two sectors also employ large, reputable coalitions in both metros.

## Calculation Process

1. Choosing a Single Year

The focus year is **2023** for both metros (excluding **2020** elsewhere due to COVID artifacts).

2. Metro-level Rent (ACS B25064: median **monthly** rent)

$$
\text{AnnualRent}_{m} = 12 \times \text{Rent}_{m}
$$

3. Sector-level wage (BLS QCEW), by two-digit NAICS root (e.g., 72 or 44) 

Aggregate all sub-industries whose code **starts with** the root, then compute the employment-weighted average wage:

$$
\text{AvgWage}*{m,s} = \frac{\sum \text{TOTAL WAGES}*{m,s}}{\sum \text{EMPLOYMENT}*{m,s}}
$$

4. Rent Burden Calculation (rent share of wage)

$$
\text{RentShare}_{m,s} =
\frac{\text{AnnualRent}_{m}}{\text{AvgWage}_{m,s}}
$$
*(Interpretation: e.g., \(0.34 = 34\%\) of an average sector wage goes to median rent.)*

5. Cross-city Rent-burden Gap (percentage points)

For **Atlanta minus Punta Gorda**:

$$
\text{Gap}_{\text{ATL}-\text{PG},\,s}
= \Big(\text{RentShare}_{\text{ATL},s} -
\text{RentShare}_{\text{PG},s}\Big)\times100\
$$

* Positive: Atlanta more rent-burdened for sector \(s\)
* Negative: Punta Gorda more rent-burdened

---

**Symbols:** \(m\) = metro; \(s\) = sector (two-digit NAICS root);
**Rent** = median monthly rent; **AnnualRent** = \(12\times\)Rent;
**AvgWage** = employment-weighted average annual wage;
**Gap** reported in **percentage points (pp)**.

---

To identify the most compelling occupations for coalition-building, the rent burden analysis in the table below shows all major economic sectors ranked by the size of the Atlanta-Punta Gorda rent burden gap.

```{r}

# Top-10 sectors by ATL vs PG rent-burden gap (2023)

# Helper: first existing column name
pick_col <- function(df, candidates, err_msg){
  nm <- intersect(candidates, names(df))
  if (length(nm) == 0) stop(err_msg, call. = FALSE)
  nm[[1]]
}

# Metro targets (CBSA + BLS FIPS-4 prefixes)
metros <- tibble::tribble(
  ~metro_key, ~metro_label,                                        ~cbsa,  ~fips4,
  "ATL",      "Atlanta–Sandy Springs–Alpharetta, GA Metro Area",   12060L, "C1206",
  "PG",       "Punta Gorda, FL Metro Area",                        39460L, "C3946"
)

# Nice names for 2-digit (and combo) NAICS roots
naics_sector_name <- function(root_chr){
  r <- str_replace_all(root_chr, "[^0-9]", "-")
  case_when(
    r == "23"    ~ "Construction",
    r %in% c("31","32","33") ~ paste0("Manufacturing (", r, ")"),
    r == "31-33" ~ "Manufacturing",
    r == "42"    ~ "Wholesale Trade",
    r == "44"    ~ "Retail: Autos/Groceries/Gas/Clothing (44xx)",
    r == "44-45" ~ "Retail Trade (44–45)",
    r == "48-49" ~ "Transportation & Warehousing",
    r == "51"    ~ "Information",
    r == "52"    ~ "Finance & Insurance",
    r == "53"    ~ "Real Estate & Rental & Leasing",
    r == "54"    ~ "Professional, Scientific & Technical",
    r == "55"    ~ "Management of Companies",
    r == "56"    ~ "Admin & Support, Waste Mgmt",
    r == "61"    ~ "Educational Services",
    r == "62"    ~ "Health Care & Social Assistance",
    r == "71"    ~ "Arts, Entertainment & Recreation",
    r == "72"    ~ "Accommodation & Food Services",
    r == "81"    ~ "Other Services",
    TRUE         ~ "Other / Unmapped"
  )
}

# Build a regex that also handles hyphenated NAICS roots (e.g., "31-33", "48-49")
build_root_pattern <- function(root) {
  if (grepl("-", root)) {
    parts <- strsplit(root, "-", fixed = TRUE)[[1]]
    paste0("^(", paste(parts, collapse = "|"), ")")
  } else {
    paste0("^", root)
  }
}

# Robust ACS column detection
rent_col <- pick_col(RENT,        c("monthly_rent", "B25064_001"),
                     "Couldn't find median rent column in RENT")
pop_col  <- pick_col(POPULATION,  c("population", "B01003_001"),
                     "Couldn't find population column in POPULATION")

# ACS slice (2023): population + median rent by CBSA, joined to metro keys
acs_23 <- POPULATION %>%
  filter(year == 2023) %>%
  mutate(cbsa = as.integer(str_extract(GEOID, "\\d+"))) %>%
  select(cbsa, population = !!sym(pop_col)) %>%
  inner_join(
    RENT %>%
      filter(year == 2023) %>%
      mutate(cbsa = as.integer(str_extract(GEOID, "\\d+"))) %>%
      select(cbsa, median_rent = !!sym(rent_col)),
    by = "cbsa"
  ) %>%
  inner_join(select(metros, cbsa, metro_key, metro_label), by = "cbsa")
stopifnot(nrow(acs_23) == 2)

# Function: rent share (median rent as % of avg wage) for a NAICS root
bls_rent_share_by_root <- function(root_code){
  patt <- build_root_pattern(root_code)
  WAGES %>%
    filter(YEAR == 2023, substr(FIPS, 1, 5) %in% metros$fips4) %>%
    filter(str_detect(as.character(INDUSTRY), patt)) %>%
    mutate(fips4 = substr(FIPS, 1, 5)) %>%
    group_by(fips4) %>%
    summarise(
      employment  = sum(EMPLOYMENT,  na.rm = TRUE),
      total_wages = sum(TOTAL_WAGES, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(avg_wage = total_wages / pmax(employment, 1)) %>%
    inner_join(select(metros, fips4, metro_key), by = "fips4") %>%
    inner_join(acs_23, by = "metro_key") %>%
    transmute(
      `NAICS Root` = root_code,
      metro_key,
      rent_share   = (median_rent * 12) / pmax(avg_wage, 1)  # proportion 0–1
    ) %>%
    pivot_wider(names_from = metro_key, values_from = rent_share)
}

# Roots to analyze (two-digit plus standard combo groups)
roots_to_show <- c(
  "72","44","62","45","56","54","31","32","33","55","42","52",
  "81","23","48-49","53","51","71","61"
)

# Build + format the Top-10 table
rent_gap_tbl <- map_dfr(roots_to_show, bls_rent_share_by_root) %>%
  filter(!is.na(ATL), !is.na(PG)) %>%
  mutate(
    Sector       = naics_sector_name(`NAICS Root`),
    ATL          = ATL * 100,                  # convert to %
    PG           = PG  * 100,                  # convert to %
    ATL_minus_PG = ATL - PG                    # percentage-point gap
  ) %>%
  select(`NAICS Root`, Sector, ATL, PG, ATL_minus_PG) %>%
  arrange(desc(ATL_minus_PG)) %>%
  slice_head(n = 10)

gt(rent_gap_tbl) %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left",
    table.font.size = px(16)
  ) %>%
  tab_header(
    title = md("**Table 3: Sector Rent-Burden Gap: Atlanta vs. Punta Gorda (Top 10, 2023)**"),
    subtitle = md("Which sectors show the largest ATL → PG rent-share differences?")
  ) %>%
  cols_label(
    `NAICS Root` = "NAICS Root",
    Sector       = "Sector",
    ATL          = "ATL (%)",
    PG           = "PG (%)",
    ATL_minus_PG = "ATL - PG"
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  fmt_number(columns = c(ATL, PG, ATL_minus_PG), decimals = 1) %>%
  cols_align(align = "left", columns = everything()) %>%
  tab_options(table.font.size = "small")

```

---

Based on this comprehensive review, two sectors emerge as optimal for coalition-building:

- 72, Accommodations & Food Services, and 
- 44, Retail Trade.

---

```{r}

# Coalition Snapshot: Food Service (72) & Retail (44) — 2023

# Helper: pick the first existing column name from a set
pick_col <- function(df, candidates, err_msg){
  nm <- intersect(candidates, names(df))
  if (!length(nm)) stop(err_msg, call. = FALSE)
  nm[[1]]
}

# Target metros (CBSA + BLS FIPS-4), with state abbrev
metros <- tibble::tribble(
  ~metro_key, ~metro_label,                                        ~cbsa,  ~fips4,  ~state_abbr,
  "ATL",      "Atlanta–Sandy Springs–Alpharetta, GA Metro Area",   12060L, "C1206", "GA",
  "PG",       "Punta Gorda, FL Metro Area",                        39460L, "C3946", "FL"
)

# Robust ACS column detection
rent_col <- pick_col(RENT,        c("monthly_rent", "B25064_001"),
                     "Couldn't find median rent column in RENT")
pop_col  <- pick_col(POPULATION,  c("population", "B01003_001"),
                     "Couldn't find population column in POPULATION")

# ACS slice (2023) joined to metro keys; derive a safe state code
acs_23 <- POPULATION %>%
  filter(year == 2023) %>%
  mutate(cbsa = as.integer(stringr::str_extract(GEOID, "\\d+"))) %>%
  select(cbsa, NAME, population = !!sym(pop_col)) %>%
  inner_join(
    RENT %>%
      filter(year == 2023) %>%
      mutate(cbsa = as.integer(stringr::str_extract(GEOID, "\\d+"))) %>%
      select(cbsa, median_rent = !!sym(rent_col)),
    by = "cbsa"
  ) %>%
  inner_join(
    select(metros, cbsa, metro_key, metro_label, metro_state = state_abbr),
    by = "cbsa"
  ) %>%
  mutate(
    state_from_name  = stringr::str_match(NAME, ",\\s([A-Z]{2})")[,2],
    state_from_label = stringr::str_match(metro_label, ",\\s([A-Z]{2})")[,2],
    state_final      = dplyr::coalesce(metro_state, state_from_name, state_from_label)
  ) %>%
  select(metro_key, metro_label, population, median_rent, state_final)

stopifnot(nrow(acs_23) == 2)

# Function: compute sector metrics for a 2-digit NAICS root (e.g., "72" or "44")
sector_metrics <- function(root_code, sector_label){
  patt <- paste0("^", root_code)
  WAGES %>%
    filter(YEAR == 2023, substr(FIPS, 1, 5) %in% metros$fips4) %>%
    filter(str_detect(as.character(INDUSTRY), patt)) %>%
    mutate(fips4 = substr(FIPS, 1, 5)) %>%
    group_by(fips4) %>%
    summarize(
      employment  = sum(EMPLOYMENT,  na.rm = TRUE),
      total_wages = sum(TOTAL_WAGES, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(avg_wage = total_wages / pmax(employment, 1)) %>%
    inner_join(select(metros, fips4, metro_key), by = "fips4") %>%
    inner_join(acs_23, by = "metro_key") %>%
    transmute(
      Metro                    = metro_label,
      State                    = state_final,
      Sector                   = sector_label,
      Employment               = employment,
      `Emp / 1k residents`     = 1000 * employment / population,
      `Avg Wage ($)`           = avg_wage,
      `Median Rent ($)`        = median_rent,
      `Rent as % of Avg Wage`  = (median_rent * 12) / pmax(avg_wage, 1) * 100
    )
}

# Build the two sectors (two-digit NAICS for consistency)
s72 <- sector_metrics("72", "Accommodation & Food Services (NAICS 72)")
s44 <- sector_metrics("44", "Retail Trade — 44xx (Autos/Groceries/Gas/Clothing)")

out_tbl <- bind_rows(s72, s44) %>%
  mutate(Metro = factor(Metro, levels = metros$metro_label)) %>%
  arrange(Metro, Sector)

# Drop Metro grouping from display; show 7 requested columns
out_tbl_display <- out_tbl %>%
  select(
    State, Sector, Employment, `Emp / 1k residents`,
    `Avg Wage ($)`, `Median Rent ($)`, `Rent as % of Avg Wage`
  )

# Render clean table (no row-group headers)
gt(out_tbl_display) %>%
    tab_options(
    table.width  = gt::pct(100),
    table.align  = "left",   # left-place the whole table block
    heading.align = "left"   # left-align title/subtitle
  ) %>%
  tab_header(
    title = md("**Table 4: Coalition Snapshot: Food Service (72) & Retail (44) — 2023**"),
    subtitle = paste(
      metros$metro_label[metros$metro_key == "ATL"], "•",
      metros$metro_label[metros$metro_key == "PG"]
    )
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  fmt_number(columns = Employment, decimals = 0, sep_mark = ",") %>%
  fmt_number(columns = `Emp / 1k residents`, decimals = 1) %>%
  fmt_currency(columns = c(`Avg Wage ($)`, `Median Rent ($)`), decimals = 0) %>%
  fmt_number(columns = `Rent as % of Avg Wage`, decimals = 1, pattern = "{x}%") %>%
  cols_align("left", columns = everything()) %>%
  tab_source_note(
    md("Sources: **BLS QCEW (employment, avg wages)** • **ACS (median rent, population)**")
  )

```

```{r}

# Rent-Share Gap (Atlanta minus Punta Gorda) — 2023 (pp)

# If sector tables from the coalition snapshot aren't in memory, build them
if (!exists("sector_metrics")) {
  stop("sector_metrics() not found. Run the coalition snapshot chunk first.")
}
if (!exists("s72") || !exists("s44")) {
  s72 <- sector_metrics("72", "Accommodation & Food Services (NAICS 72)")
  s44 <- sector_metrics("44", "Retail Trade — 44xx (NAICS 44)")
}

# Assemble and pivot wide
gap_input <- bind_rows(s72, s44) %>%
  select(Sector, Metro, `Rent as % of Avg Wage`)

rent_share_wide <- gap_input %>%
  pivot_wider(names_from = Metro, values_from = `Rent as % of Avg Wage`)

# Metro labels (from your metros tibble)
atl_name <- metros$metro_label[metros$metro_key == "ATL"]
pg_name  <- metros$metro_label[metros$metro_key == "PG"]

# Compute ATL – PG in percentage points (already percent values)
gap_tbl <- rent_share_wide %>%
  transmute(
    Sector,
    `ATL – PG (pp)` = .data[[atl_name]] - .data[[pg_name]]
  )

# Render
gt(gap_tbl) %>%
    tab_options(
    table.width  = gt::pct(100),
    table.align  = "left",   
    heading.align = "left"    
  ) %>%
  tab_header(title = md("**Table 5: Rent-Share Gap (Atlanta minus Punta Gorda) — 2023**")) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  fmt_number(columns = `ATL – PG (pp)`, decimals = 1)


```
---

Atlanta exemplifies the supply-constrained growth pattern federal YIMBY grants target: 6.3 million residents growing 12.4% over five years, yet rent burden worsened by 3.0 percentage points—the most among large metros—due to below-average housing construction (score: 84). This gap corresponds to 1.2 million service workers paying 4-10 percentage points more of their wages toward rent compared to workers in successful metros.

---

## Unlocking Atlanta Metro's Housing Supply and Job Growth

The Atlanta metro currently employs 331,350 construction workers. If the metro matched Punta Gorda's proven construction intensity of 102.9 workers per 1,000 residents, it would sustain 648,834 construction jobs, representing a potential increase of approximately 317,000 jobs (or 96% sector growth). More construction workers can lead to more housing built, placing more housing in the supply to reduce pressure on rents.


```{r}

#| label: construction-mechanism
#| code-fold: true
#| echo: false
#| warning: false
#| message: false

# Data extraction (no output) 
s23 <- sector_metrics("23", "Construction (NAICS 23)")

# Get values using NAME search
atl_row_data <- combined_analysis %>% 
  filter(grepl("Atlanta", NAME, ignore.case = TRUE))
atl_pop_value <- atl_row_data$population[1]
atl_housing_value <- atl_row_data$composite_score[1]

pg_row_data <- combined_analysis %>% 
  filter(grepl("Punta", NAME, ignore.case = TRUE))
pg_pop_value <- pg_row_data$population[1]
pg_housing_value <- pg_row_data$composite_score[1]

# Get construction data from s23
pg_const <- s23 %>% filter(State == "FL") %>% pull(`Emp / 1k residents`)
pg_employment <- s23 %>% filter(State == "FL") %>% pull(Employment)
pg_metro_name <- s23 %>% filter(State == "FL") %>% pull(Metro)

atl_const <- s23 %>% filter(State == "GA") %>% pull(`Emp / 1k residents`)
atl_employment <- s23 %>% filter(State == "GA") %>% pull(Employment)
atl_metro_name <- s23 %>% filter(State == "GA") %>% pull(Metro)

# Calculate job creation potential
jobs_at_pg_intensity <- round(atl_pop_value * (pg_const / 1000))
job_gap <- jobs_at_pg_intensity - atl_employment

# Build mechanism table
mechanism_table <- tibble(
  Metro = c(pg_metro_name, atl_metro_name),
  State = c("FL", "GA"),
  `Construction jobs per 1K` = c(pg_const, atl_const),
  `Housing Score` = c(pg_housing_value, atl_housing_value),
  `Hospitality Burden (%)` = c(
    s72 %>% filter(State == "FL") %>% pull(`Rent as % of Avg Wage`),
    s72 %>% filter(State == "GA") %>% pull(`Rent as % of Avg Wage`)
  ),
  `Retail Burden (%)` = c(
    s44 %>% filter(State == "FL") %>% pull(`Rent as % of Avg Wage`),
    s44 %>% filter(State == "GA") %>% pull(`Rent as % of Avg Wage`)
  )
)

# Calculate key metrics
const_diff_pct <- round(((pg_const - atl_const) / atl_const) * 100, 0)
housing_diff_pct <- round(((pg_housing_value - atl_housing_value) / atl_housing_value) * 100, 0)

pg_hosp <- mechanism_table %>% filter(State == "FL") %>% pull(`Hospitality Burden (%)`)
atl_hosp <- mechanism_table %>% filter(State == "GA") %>% pull(`Hospitality Burden (%)`)
hosp_gap <- round(atl_hosp - pg_hosp, 1)

pg_retail <- mechanism_table %>% filter(State == "FL") %>% pull(`Retail Burden (%)`)
atl_retail <- mechanism_table %>% filter(State == "GA") %>% pull(`Retail Burden (%)`)
retail_gap <- round(atl_retail - pg_retail, 1)

hosp_wage <- s72 %>% filter(State == "GA") %>% pull(`Avg Wage ($)`)
retail_wage <- s44 %>% filter(State == "GA") %>% pull(`Avg Wage ($)`)

hosp_savings <- round((hosp_gap / 100) * hosp_wage, 0)
retail_savings <- round((retail_gap / 100) * retail_wage, 0)

```

```{r}

#| label: construction-tables
#| code-fold: true

# Display mechanism table
gt(mechanism_table) %>%
    tab_options(
    table.width  = gt::pct(100),
    table.align  = "left",   
    heading.align = "left"   
  ) %>%
  tab_header(
    title = md("**Table 6: The Construction Mechanism: Building Intensity → Supply → Affordability**"),
    subtitle = "How construction employment drives housing supply and worker rent burden (2023)"
  ) %>%
  fmt_number(columns = `Construction jobs per 1K`, decimals = 1) %>%
  fmt_number(columns = `Housing Score`, decimals = 1) %>%
  fmt_number(columns = c(`Hospitality Burden (%)`, `Retail Burden (%)`), decimals = 1) %>%
  cols_align("left", columns = everything()) %>%
  tab_style(
    style = cell_fill(color = "#d4edda"),
    locations = cells_body(rows = State == "FL")
  ) %>%
  tab_style(
    style = cell_fill(color = "#fff3cd"),
    locations = cells_body(rows = State == "GA")
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(
    md("**Pattern:** Higher construction intensity → Higher housing score → Lower rent burden")
  )
```


```{r}
# Job creation table
job_table <- tibble(
  Metro = atl_metro_name,
  `Current Jobs` = atl_employment,
  `Jobs at PG Rate` = jobs_at_pg_intensity,
  `Job Gap (+)` = job_gap
)

gt(job_table) %>%
    tab_options(
    table.width  = gt::pct(100),
    table.align  = "left",    
    heading.align = "left"  
  ) %>%
  tab_header(
    title = md("**Table 7: Atlanta Construction Employment Projection**"),
    subtitle = "*Job creation potential if Atlanta matched Punta Gorda's construction jobs rate"
  ) %>%
  fmt_number(columns = c(`Current Jobs`, `Jobs at PG Rate`, `Job Gap (+)`), 
             decimals = 0, sep_mark = ",") %>%
  cols_align("left", columns = Metro) %>%
  cols_align("right", columns = c(`Current Jobs`, `Jobs at PG Rate`, `Job Gap (+)`)) %>%
  tab_style(
    style = cell_fill(color = "#d1ecf1"),
    locations = cells_body(columns = `Job Gap (+)`)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = `Job Gap (+)`)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(
    md("**Calculation:** Atlanta population × Punta Gorda construction per 1K rate")
  )

```

*Note:  This projection is likely high based on a simple "linear" assumption that the number of construction jobs will increase at similar rates as population.*

---

This outcome is plausible as Punta Gorda has sustained a high building rate for years while keeping housing affordable for workers. The relationship between construction intensity, housing supply, and worker affordability is clearer when comparing these two growing metros using the table below.

---

```{r}

#| label: task7-affordability-comparison-table
#| code-fold: true

# Create the comparison table
affordability_table <- tibble(
  Metric = c(
    "Construction Intensity",
    "Housing Supply Index",
    "Hospitality Worker Burden",
    "Retail Worker Burden",
    "Worker Population",
    "Total Annual Impact"
  ),
  `Punta Gorda, FL (Success)` = c(
    "102.9 workers per 1,000 residents",
    "291.7 (3× national average)",
    "65.3% of wage to rent",
    "37.4% of wage to rent",
    "38,000 service workers",
    "Baseline (affordable)"
  ),
  `Atlanta, GA (Opportunity)` = c(
    "52.5 per 1,000 residents",
    "84 (17% below average)",
    "74.8% (+9.6pp)",
    "41.3% (+4.0pp)",
    "1.2M service workers",
    "$3B in excess rent burden"
  ),
  `The Gap` = c(
    "Atlanta builds at half PG's rate",
    "PG produces 3.5× more housing per capita",
    "Costs Atlanta workers $2,619/year more",
    "Costs Atlanta workers $1,976/year more",
    "—",
    "Support unlocks $3B in savings"
  )
)

# Render with gt
gt(affordability_table) %>%
  tab_options(
    table.width = pct(100),
    table.align = "left",
    heading.align = "left"
  ) %>%
  tab_header(
    title = md("**Table 8: How Building Drives Affordability: Punta Gorda vs. Atlanta**")
  ) %>%
  cols_align("left", columns = everything()) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = Metric)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d4edda"),
    locations = cells_body(columns = `Punta Gorda, FL (Success)`)
  ) %>%
  tab_style(
    style = cell_fill(color = "#fff3cd"),
    locations = cells_body(columns = `Atlanta, GA (Opportunity)`)
  ) %>%
  tab_style(
    style = cell_fill(color = "#d1ecf1"),
    locations = cells_body(columns = `The Gap`)
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
    ) %>%
  tab_source_note(
    md("*Source: 2023 ACS B25064 (median rent), BLS QCEW (average wages), Census Building Permits*")
  )

```

**Conclusion:** Federal support to help Atlanta build like Punta Gorda could restore $3 billion annually to working families while creating 317,000+ construction jobs.

---

## **The Federal YIMBY Housing Growth Incentive Bill: A Policy Brief**

**TO:** Interested Congressional Members 
**RE:** Proposed Sponsors: A primary sponsor from Punta Gorda, FL (YIMBY Success) and a co-sponsor from Atlanta, GA (Opportunity City)
**ASK:** Join as a co-sponsor of the Federal YIMBY Housing Growth Incentive Bill, a **voluntary, no-mandates** $500M competitive-grant program that rewards cities for adding homes and lowering rent burden.

---

## **1. How the Program Works**

This voluntary, no-mandates program uses existing federal data (Census and BLS) and discretionary spending to direct funds where they produce results.

- **Eligibility:** Open to all metropolitan areas through competitive application. 
- **Scale:** $500M over five years; grants range from $5M-$50M per metro.
- **Awards:** Planning Grants ($5-15M) for zoning and permitting updates, plus Performance Grants ($25-50M) for areas documenting improvements in housing supply and lowering rent burden.

---

## **2. A Bipartisan Sponsorship Strategy: "Success" and "Opportunity"**

Our strategy pairs two districts to prove the model is effective and necessary.

**YIMBY Success Sponsor: Punta Gorda, FL**

- Building at three times the national average (Housing Growth Index: 291.7)
- Kept rent pressure low despite 13.2% population growth
- Qualifies for immediate implementation grants

**Opportunity Co-Sponsor: Atlanta, GA**  

- Construction 17% below national average (Housing Growth Index: 84)
- Despite 12.4% population growth, rent burden worsened by 3.0pp
- Federal support can create approximately **317,000 construction jobs** (96% increase from current 331K)

**2023 Evidence (ACS B25064; BLS QCEW):**

- Hospitality (NAICS 72) Rent Burden: ATL 74.8% vs. PG 65.3% (9.6pp gap = **$2,619/year/worker**)
- Retail (NAICS 44) Rent Burden: ATL 41.3% vs. PG 37.4% (4.0pp gap = **$1,976/year/worker**)

---

## **3. Why This Bill? A Pro-Worker, Pro-Business Coalition**

This data provides a powerful, targeted message for local supporters:

- **For Construction Trades** (AFL-CIO Building Trades, National Association of Home Builders): Atlanta matching Punta Gorda's building rate creates approximately **317,000 additional jobs**, higher-paying, non-outsourceable employment that supports local trade unions and contractors.
- **For Service Workers** (UNITE HERE, United Food and Commercial Workers): Reduces the 9.6pp rent-burden gap for Hospitality workers (**$2,619 savings**) and 4.0pp for Retail workers (**$1,976 savings**). **Scale:** 1,200,000 workers in Atlanta, 38K in Punta Gorda (BLS QCEW 2023). **Total wage power restored: ~$3 billion.**
- **For Business** (Chambers of Commerce, employers): This bill tackles the primary barrier to employee hiring and retention: high housing costs. By increasing housing supply, it helps ensure workers can afford to live in the communities where they work. 

This bill creates approximately 317,000 jobs, saves workers $2,400 annually, and restores $3 billion in aggregate wages, resulting in a pro-worker, pro-business solution with no mandates.

---

## **4. Scoring & Program Safeguards**

**Scoring Metrics:**

- **Rent Burden by Sector:** Share of a typical Hospitality (NAICS 72) or Retail (NAICS 44) worker's wage that median local rent would consume.
  * Formula: (ACS B25064 median rent × 12) ÷ (BLS QCEW average wage) × 100

- **Housing Growth Index:** Are new housing permits keeping pace with metro size and five-year population growth? (Higher = building enough to meet demand.)
  * Indexed to national average (100)

- **Awards** scale with improvement vs. national average and each city's five-year baseline.

**Program Safeguards:**

- **Accountability:** Public dashboards track results; independent audits verify spending; five-year sunset forces evaluation before renewal, with expectations for rising building permits (years 2-3), increases in local construction jobs (years 3-4), and measurable relief from high rents (years 4-5). 
- **Community Protections:** Funded projects must include tenant protections, affordable unit preservation requirements, and prioritize development near jobs and transit.
- **Administration:** Uses existing <a href="https://www.hudexchange.info/programs/grants-management/#grants-management-lifecycle" target="_blank">HUD competitive grant processes </a>, simplifying the application process. 

---

## **5. The Path Forward**

This proposed bill is a sensible solution uniting business and labor: it creates 300K+ construction jobs, saves working families $2,400 annually, and helps employers fill positions. **Potential impact: $3 billion in restored wage power.** Also, by proposing it as a discretionary spending bill, it avoids the need for new budget authorization (existing line item in <a href="https://www.hud.gov/hud-partners/community-cdbg#eg" target="_blank"> HUD's Community Development Block Grant Program</a>).

**Timeline:** Seeking co-sponsors for early 2026 introduction.